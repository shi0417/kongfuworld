# 作者后台章节相关功能现状分析报告

**生成时间**：2025-12-06  
**分析目标**：梳理章节上传、章节管理、草稿箱功能的现状和逻辑关系，分析「缺少第 135 章」和「出现两个第 136 章」的可能原因

---

## 一、数据库表结构与约束梳理

### 1.1 chapter 表（章节表）

**表结构定义位置**：`backend/database_schema.sql` (第 6-24 行)

**核心字段**：

| 字段名 | 类型 | 是否为空 | 说明 |
|--------|------|----------|------|
| `id` | int | NOT NULL | 主键，自增 |
| `novel_id` | int | NOT NULL | 小说ID（外键关联 `novel.id`） |
| `volume_id` | int | NOT NULL | 卷ID（关联 `volume.id` 或 `volume.volume_id`） |
| `chapter_number` | int | NOT NULL | **章节编号**（关键字段） |
| `title` | varchar(255) | NOT NULL | 章节标题 |
| `content` | text | YES | 章节内容 |
| `review_status` | enum | NOT NULL | 审核状态：`'submitted'`, `'reviewing'`, `'approved'`, `'rejected'`, `'draft'` |
| `is_released` | tinyint(1) | DEFAULT '1' | 是否已发布（0=未发布，1=已发布） |
| `release_date` | datetime | NULL | 发布日期 |
| `created_at` | datetime | DEFAULT CURRENT_TIMESTAMP | 创建时间 |
| `updated_at` | datetime | DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP | 更新时间 |

**索引与约束**：

- **主键**：`PRIMARY KEY (id)`
- **普通索引**：`KEY novel_id (novel_id)`
- **外键约束**：`CONSTRAINT chapter_ibfk_1 FOREIGN KEY (novel_id) REFERENCES novel (id)`

**⚠️ 关键发现**：

1. **没有 `(novel_id, chapter_number)` 的唯一约束**
   - 这意味着同一本小说可以存在多个 `chapter_number` 相同的章节
   - 这是导致「出现两个第 136 章」的**根本原因**

2. **没有 `volume_id` 的外键约束**
   - `volume_id` 字段存在，但没有外键约束
   - 可能导致「孤立章节」（`volume_id` 指向不存在的卷）

3. **草稿与正式章节共用同一张表**
   - 通过 `review_status = 'draft'` 区分草稿
   - 没有单独的草稿表（如 `chapter_draft`）

### 1.2 volume 表（卷轴表）

**表结构定义位置**：`backend/database_schema.sql` (第 204-216 行)

**核心字段**：

| 字段名 | 类型 | 是否为空 | 说明 |
|--------|------|----------|------|
| `id` | int | NOT NULL | 主键，自增 |
| `novel_id` | int | NOT NULL | 小说ID（外键关联 `novel.id`） |
| `volume_id` | int | NOT NULL | **卷ID**（用于关联章节，旧设计使用此字段） |
| `title` | varchar(255) | NULL | 卷标题 |
| `start_chapter` | int | NULL | 起始章节号 |
| `end_chapter` | int | NULL | 结束章节号 |
| `chapter_count` | int | DEFAULT 0 | 章节数量 |

**索引与约束**：

- **主键**：`PRIMARY KEY (id)`
- **普通索引**：`KEY novel_id (novel_id)`
- **外键约束**：`CONSTRAINT volume_ibfk_1 FOREIGN KEY (novel_id) REFERENCES novel (id)`

**⚠️ 关键发现**：

1. **存在设计混淆**：
   - `volume.id`：数据库主键（自增）
   - `volume.volume_id`：卷序号（1, 2, 3...）
   - `chapter.volume_id` 可能关联 `volume.id`（新设计）或 `volume.volume_id`（旧设计）

2. **没有「最后一个卷轴」的明确排序依据**
   - 可以通过 `MAX(volume_id)` 或 `MAX(id)` 获取
   - 但代码中未统一使用

### 1.3 其他相关表

**draft 表**（独立草稿表，但似乎未被使用）：
- 位置：`backend/routes/draft.js`
- 说明：存在独立的 `draft` 表，但章节草稿功能实际使用的是 `chapter` 表的 `review_status = 'draft'`

**chapter_review_log 表**（审核日志）：
- 用于记录章节审核历史
- 不影响章节编号逻辑

---

## 二、后端业务逻辑梳理

### 2.1 章节上传 & 保存草稿

**接口路径**：`POST /api/chapter/create`  
**文件位置**：`backend/routes/novelCreation.js` (第 1126-1462 行)

**请求参数**：

```javascript
{
  novel_id: number,           // 必填
  chapter_number: number,      // 必填（由前端传入）
  title: string,              // 必填
  content: string,            // 可选
  translator_note: string,    // 可选
  is_draft: '0' | '1',        // 默认为 '1'（存为草稿）
  is_released: '0' | '1',     // 默认为 '1'
  release_date: string,       // 可选（定时发布时间）
  word_count: number          // 可选
}
```

**核心逻辑**：

1. **章节编号（chapter_number）**：
   - **由前端传入**，后端不自动生成
   - 前端通过 `/chapters/novel/:novelId/next-number` 接口获取建议的章节号
   - **问题**：前端可以手动修改章节号，后端不做唯一性校验

2. **卷轴（volume_id）**：
   ```javascript
   // 第 1164 行：硬编码为 1
   const volume_id = 1;
   ```
   - **问题**：无论前端是否选择卷轴，后端都使用 `volume_id = 1`
   - 没有获取「最后一个卷轴」的逻辑
   - 没有自动创建「第一卷」的逻辑

3. **审核状态（review_status）**：
   ```javascript
   // 第 1174-1175 行
   if (is_draft === '1' || is_draft === 1) {
     reviewStatus = 'draft';
   } else {
     reviewStatus = 'submitted';
   }
   ```

4. **插入章节**：
   ```sql
   INSERT INTO chapter (
     novel_id, volume_id, chapter_number, title, content,
     translator_note, is_advance, key_cost, unlock_price,
     review_status, word_count, is_released, release_date
   ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
   ```

**章节号生成接口**：`GET /chapters/novel/:novelId/next-number`  
**文件位置**：`backend/routes/novelCreation.js` (第 812-838 行)

**核心 SQL**：

```sql
SELECT MAX(chapter_number) as max_chapter_number
FROM chapter
WHERE novel_id = ?
```

**⚠️ 关键问题**：

1. **查询所有状态的章节**（包括草稿）
   - 如果存在 `chapter_number = 135` 的草稿，下一个章节号会是 136
   - 如果草稿被删除或发布后，可能造成编号空洞

2. **没有唯一性校验**
   - 即使查询到 `max_chapter_number = 135`，如果同时存在 `chapter_number = 135` 的草稿和已发布章节，也不会报错

### 2.2 草稿箱 -> 发布

**接口路径**：`POST /api/chapter/:chapterId/submit`  
**文件位置**：`backend/routes/novelCreation.js` (第 999-1020 行)

**核心逻辑**：

1. **检查章节状态**：
   ```sql
   SELECT id, review_status FROM chapter WHERE id = ?
   ```
   - 只允许 `review_status = 'draft'` 的章节提交

2. **更新状态**：
   ```sql
   UPDATE chapter 
   SET review_status = 'submitted' 
   WHERE id = ?
   ```
   - **不重新生成 `chapter_number`**
   - **不插入新行**，只更新现有行的状态

**⚠️ 关键问题**：

1. **草稿发布时保留原有 `chapter_number`**
   - 如果草稿的 `chapter_number = 136`，发布后仍然是 136
   - 如果此时已存在 `chapter_number = 136` 的已发布章节，就会出现两个 136 章

2. **没有检查 `chapter_number` 冲突**
   - 发布时没有验证是否已存在相同 `chapter_number` 的已发布章节

### 2.3 章节管理列表接口

**接口路径**：`GET /api/chapters/novel/:novelId`  
**文件位置**：`backend/routes/novelCreation.js` (第 926-968 行)

**核心 SQL**：

```sql
SELECT 
  c.id,
  c.chapter_number,
  c.title,
  COALESCE(c.word_count, LENGTH(c.content)) as word_count,
  c.review_status,
  c.created_at,
  c.release_date,
  c.is_released,
  c.unlock_price,
  c.volume_id
FROM chapter c
WHERE c.novel_id = ? 
  AND c.review_status != 'draft'  -- 排除草稿
ORDER BY c.chapter_number DESC
```

**查询参数**：
- `review_status`：可筛选特定审核状态
- `volumeId`：可筛选特定卷轴
- `sort`：排序方式（'asc' 或 'desc'，默认 'desc'）

**⚠️ 关键发现**：

1. **排除草稿状态**
   - 只显示 `review_status != 'draft'` 的章节
   - 如果第 135 章是草稿状态，不会出现在列表中

2. **按 `chapter_number` 排序**
   - 使用数据库中的 `chapter_number` 字段排序
   - 不是前端数组索引

### 2.4 草稿箱列表接口

**接口路径**：`GET /api/chapters/novel/:novelId/drafts`  
**文件位置**：`backend/routes/novelCreation.js` (第 971-996 行)

**核心 SQL**：

```sql
SELECT 
  id,
  chapter_number,
  title,
  COALESCE(word_count, LENGTH(content)) as word_count,
  created_at
FROM chapter
WHERE novel_id = ? 
  AND review_status = 'draft'  -- 只查询草稿
ORDER BY chapter_number DESC
```

**⚠️ 关键发现**：

1. **草稿和已发布章节共用 `chapter_number`**
   - 草稿可以有 `chapter_number = 135`
   - 已发布章节也可以有 `chapter_number = 135`
   - 两者不会冲突（因为查询时用 `review_status` 区分）

2. **可能导致的问题**：
   - 如果第 135 章是草稿，在「章节管理」中看不到
   - 如果第 136 章是已发布，在「章节管理」中可以看到
   - 如果同时存在 `chapter_number = 136` 的草稿和已发布章节，两个列表都会显示 136 章

---

## 三、卷轴（volume）默认逻辑梳理

### 3.1 卷轴列表接口

**接口路径**：`GET /api/novels/:novelId/volumes`  
**文件位置**：`backend/routes/novelCreation.js` (第 1038-1060 行)

**核心 SQL**：

```sql
SELECT 
  id,
  novel_id,
  volume_id,
  title
FROM volume
WHERE novel_id = ?
ORDER BY volume_id ASC
```

**返回数据**：按 `volume_id` 升序排列的卷轴列表

### 3.2 章节创建时的卷轴处理

**文件位置**：`backend/routes/novelCreation.js` (第 1163-1164 行)

**当前逻辑**：

```javascript
// 第 1163-1164 行：硬编码为 1
const volume_id = 1;
```

**⚠️ 关键问题**：

1. **硬编码为 1**
   - 无论前端是否选择卷轴，后端都使用 `volume_id = 1`
   - **没有从请求参数中读取 `volume_id`**（前端也没有传递此参数）

2. **没有获取「最后一个卷轴」的逻辑**
   - 应该查询 `MAX(volume_id)` 或 `MAX(id)` 作为默认值
   - 当前代码没有实现

3. **没有自动创建「第一卷」的逻辑**
   - 如果小说没有任何卷轴，应该自动创建 `volume_id = 1` 的卷轴
   - 当前代码没有实现

4. **更新章节时有卷轴处理逻辑，但创建章节时没有**
   - `PATCH /chapter/:chapterId/volume` 接口（第 1063 行）可以更新章节的卷轴
   - 但创建章节时无法指定卷轴

### 3.3 前端卷轴选择逻辑

**文件位置**：`frontend/src/pages/ChapterWriter.tsx`

**发现**：
- 前端代码中没有找到卷轴选择相关的逻辑
- 章节上传页面可能没有卷轴下拉框，或者卷轴选择功能未实现

---

## 四、关于「缺少 135 章 & 出现两个 136 章」的可能成因分析

### 4.1 可能原因 1：草稿与已发布章节使用相同的 `chapter_number`

**场景描述**：

1. 用户创建了第 135 章，保存为草稿（`review_status = 'draft'`, `chapter_number = 135`）
2. 用户创建了第 136 章，直接发布（`review_status = 'submitted'`, `chapter_number = 136`）
3. 在「章节管理」列表中：
   - 看不到第 135 章（因为是草稿，被 `review_status != 'draft'` 过滤）
   - 可以看到第 136 章
4. 在「草稿箱」列表中：
   - 可以看到第 135 章（`review_status = 'draft'`）

**证据**：
- `GET /chapters/novel/:novelId` 接口：`WHERE c.review_status != 'draft'`
- `GET /chapters/novel/:novelId/drafts` 接口：`WHERE review_status = 'draft'`
- 两个接口都使用 `chapter_number` 字段，但通过 `review_status` 区分

**结论**：这是最有可能的原因。

---

### 4.2 可能原因 2：草稿发布时没有检查 `chapter_number` 冲突

**场景描述**：

1. 用户创建了第 136 章草稿（`chapter_number = 136`, `review_status = 'draft'`）
2. 用户又创建了第 136 章并直接发布（`chapter_number = 136`, `review_status = 'submitted'`）
3. 此时数据库中存在两条记录：
   - 记录 A：`chapter_number = 136`, `review_status = 'draft'`
   - 记录 B：`chapter_number = 136`, `review_status = 'submitted'`
4. 用户将草稿 A 发布（更新为 `review_status = 'submitted'`）
5. 此时数据库中存在两条记录：
   - 记录 A：`chapter_number = 136`, `review_status = 'submitted'`
   - 记录 B：`chapter_number = 136`, `review_status = 'submitted'`
6. 在「章节管理」列表中，会显示两个第 136 章

**证据**：
- `POST /chapter/:chapterId/submit` 接口：只更新 `review_status`，不检查 `chapter_number` 冲突
- `chapter` 表没有 `(novel_id, chapter_number)` 的唯一约束

**结论**：这是导致「出现两个 136 章」的**根本原因**。

---

### 4.3 可能原因 3：章节号生成逻辑统计了所有状态的章节

**场景描述**：

1. 用户创建了第 135 章草稿（`chapter_number = 135`）
2. 用户创建新章节时，调用 `/chapters/novel/:novelId/next-number` 接口
3. 接口查询 `MAX(chapter_number)`，返回 135
4. 前端计算 `next_chapter_number = 135 + 1 = 136`
5. 用户创建第 136 章并发布
6. 如果第 135 章草稿被删除或修改为其他编号，就会出现「缺少 135 章」的情况

**证据**：
- `GET /chapters/novel/:novelId/next-number` 接口：
  ```sql
  SELECT MAX(chapter_number) as max_chapter_number
  FROM chapter
  WHERE novel_id = ?
  ```
  - 没有过滤 `review_status`，会统计所有状态的章节

**结论**：这可能导致章节号分配不合理，但不直接导致「缺少 135 章」。

---

### 4.4 可能原因 4：章节删除或状态变更后没有重新整理编号

**场景描述**：

1. 用户创建了第 135 章并发布（`chapter_number = 135`, `review_status = 'approved'`）
2. 用户删除了第 135 章（或将其状态改为 `'rejected'`）
3. 用户创建新章节时，仍然使用 `MAX(chapter_number) + 1 = 136`
4. 在「章节管理」列表中，看不到第 135 章（因为被删除或状态不是 `'approved'`）
5. 如果第 135 章的状态是 `'rejected'`，它也不会出现在列表中（因为 `review_status != 'draft'` 可能只显示 `'approved'` 的章节）

**证据**：
- 章节管理列表接口：`WHERE c.review_status != 'draft'`
- 如果章节状态是 `'rejected'`，仍然会被查询到
- 但如果章节被删除（`is_deleted = 1`，如果存在此字段），则不会被查询到

**结论**：这可能导致「缺少 135 章」，但需要确认是否有删除标记字段。

---

## 五、总结

### 5.1 核心问题

1. **数据库层面**：
   - ❌ `chapter` 表没有 `(novel_id, chapter_number)` 的唯一约束
   - ❌ 允许同一本小说存在多个相同 `chapter_number` 的章节

2. **业务逻辑层面**：
   - ❌ 草稿发布时没有检查 `chapter_number` 冲突
   - ❌ 章节号生成逻辑统计了所有状态的章节（包括草稿）
   - ❌ 卷轴默认逻辑硬编码为 `volume_id = 1`

3. **数据展示层面**：
   - ⚠️ 「章节管理」和「草稿箱」使用不同的查询条件
   - ⚠️ 可能导致同一 `chapter_number` 在不同列表中显示

### 5.2 最可能的成因

**「缺少第 135 章」**：
- 第 135 章是草稿状态（`review_status = 'draft'`）
- 「章节管理」列表排除了草稿，所以看不到

**「出现两个第 136 章」**：
- 存在两条 `chapter_number = 136` 的记录
- 一条是草稿发布后的，一条是直接创建的
- 由于没有唯一约束，两条记录都保存成功
- 「章节管理」列表显示两条记录，都显示为「第 136 章」

### 5.3 需要进一步确认的问题

1. 数据库中是否真的存在两条 `chapter_number = 136` 的记录？
2. 第 135 章是否真的存在，但状态是 `'draft'`？
3. 是否有章节删除功能，以及删除后如何处理 `chapter_number`？

---

**报告结束**

