# 作者基础收入表（author_royalty）生成逻辑说明

## 一、完整代码逻辑流程

### 1. 入口
- **前端页面**：`frontend/src/pages/AdminPanel/AuthorRoyalty/index.tsx`
- **API 路由**：`POST /api/admin/author-royalty/generate`
- **后端文件**：`backend/routes/admin.js` 第 2288-2467 行

### 2. 完整执行流程

```
┌─────────────────────────────────────────────────────────────┐
│  1. 接收前端参数                                             │
│     - month: "2025-11" (YYYY-MM 格式)                       │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  2. 参数验证                                                 │
│     - 检查 month 是否存在                                    │
│     - 如果不存在，返回 400 错误                              │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  3. 连接数据库                                               │
│     - 创建 MySQL 连接                                        │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  4. 月份格式转换                                             │
│     - 前端: "2025-11"                                        │
│     - 后端: "2025-11-01" (settlementMonth)                  │
│     - 日志: [author-royalty/generate] month: 2025-11       │
│             settlementMonth: 2025-11-01                      │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  5. 检查是否已生成过                                          │
│     SQL: SELECT COUNT(*) FROM author_royalty                │
│           WHERE settlement_month = '2025-11-01'              │
│     - 如果 count > 0，返回 400 错误                          │
│     - 错误信息: "该月份数据已存在，请先删除后再生成"          │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  6. 查询 reader_spending 数据                                │
│     SQL: SELECT rs.id, rs.user_id, rs.novel_id,            │
│                rs.amount_usd, rs.spend_time,                │
│                rs.source_type                                │
│          FROM reader_spending rs                            │
│          WHERE rs.settlement_month = '2025-11-01'           │
│          ORDER BY rs.spend_time                             │
│                                                              │
│     ⚠️ 关键点：                                               │
│     - 只按 settlement_month 过滤                            │
│     - 不区分 source_type（章节解锁/订阅）                   │
│     - 不区分 settled 状态                                    │
│     - 日志: [author-royalty/generate] spendings count: X    │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  7. 检查 reader_spending 是否为空                            │
│     - 如果 spendings.length === 0，返回 400 错误            │
│     - 错误信息: "该月份没有读者消费数据，请先生成基础收入数据" │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  8. 循环处理每条 reader_spending 记录                        │
│     for (const spending of spendings) {                     │
│       try {                                                  │
│         ...                                                  │
│       } catch (insertError) {                               │
│         ...                                                  │
│       }                                                      │
│     }                                                        │
└─────────────────────────────────────────────────────────────┘
                        ↓
        ┌───────────────────────────────┐
        │  8.1 获取小说的作者ID          │
        │  SQL: SELECT user_id           │
        │        FROM novel              │
        │        WHERE id = ?            │
        │                               │
        │  ⚠️ 如果 novel 不存在或        │
        │     user_id 为 NULL，跳过      │
        │  日志: [author-royalty/       │
        │        generate] 小说 X        │
        │        没有作者，跳过           │
        └───────────────────────────────┘
                        ↓
        ┌───────────────────────────────┐
        │  8.2 查找分成合同              │
        │  SQL: SELECT plan_id           │
        │        FROM novel_royalty_     │
        │              contract          │
        │        WHERE novel_id = ?      │
        │          AND author_id = ?     │
        │          AND effective_from    │
        │              <= ?              │
        │          AND (effective_to     │
        │              IS NULL OR         │
        │              effective_to > ?)  │
        │        ORDER BY effective_from │
        │                 DESC          │
        │        LIMIT 1                 │
        └───────────────────────────────┘
                        ↓
        ┌───────────────────────────────┐
        │  8.3 确定分成比例              │
        │                               │
        │  如果找到合同：                 │
        │    SQL: SELECT royalty_percent │
        │          FROM author_royalty_  │
        │                plan           │
        │          WHERE id = ?          │
        │                               │
        │  如果没有合同：                 │
        │    SQL: SELECT royalty_percent │
        │          FROM author_royalty_  │
        │                plan           │
        │          WHERE is_default = 1  │
        │          ORDER BY start_date   │
        │                   DESC        │
        │          LIMIT 1               │
        │                               │
        │  如果都没有：                   │
        │    使用默认值 0.5 (50%)        │
        └───────────────────────────────┘
                        ↓
        ┌───────────────────────────────┐
        │  8.4 计算金额                  │
        │  grossAmountUsd =              │
        │    new Decimal(spending.       │
        │              amount_usd)       │
        │                               │
        │  authorAmountUsd =             │
        │    grossAmountUsd ×            │
        │    royaltyPercent              │
        │                               │
        │  ⚠️ 使用 Decimal.js 高精度计算 │
        └───────────────────────────────┘
                        ↓
        ┌───────────────────────────────┐
        │  8.5 插入 author_royalty      │
        │  SQL: INSERT INTO author_      │
        │              royalty          │
        │        (author_id, novel_id,   │
        │         source_spend_id,      │
        │         gross_amount_usd,      │
        │         author_amount_usd,     │
        │         settlement_month)      │
        │        VALUES (?, ?, ?, ?, ?, ?)│
        │                               │
        │  ⚠️ 如果插入失败，catch 捕获    │
        │     记录错误但继续处理下一条    │
        └───────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│  9. 返回结果                                                 │
│     - 成功生成数量: generatedCount                          │
│     - 跳过数量: skippedCount                                │
│     - 跳过原因: skippedReasons                              │
│     - 日志: [author-royalty/generate] generated rows: X     │
└─────────────────────────────────────────────────────────────┘
```

---

## 二、关键代码片段

### 1. reader_spending 查询

```javascript
const [spendings] = await db.execute(
  `SELECT 
    rs.id,
    rs.user_id,
    rs.novel_id,
    rs.amount_usd,
    rs.spend_time,
    rs.source_type
  FROM reader_spending rs
  WHERE rs.settlement_month = ?
  ORDER BY rs.spend_time`,
  [settlementMonth]  // settlementMonth = '2025-11-01'
);
```

**查询条件说明**：
- ✅ 只按 `settlement_month` 过滤
- ✅ 不区分 `source_type`（章节解锁/订阅）
- ✅ 不区分 `settled` 状态
- ✅ 符合业务规则：当月所有 reader_spending 都应该参与作者分成

### 2. novel 作者ID检查

```javascript
const [novels] = await db.execute(
  'SELECT user_id FROM novel WHERE id = ?',
  [spending.novel_id]
);

if (novels.length === 0 || !novels[0].user_id) {
  skippedCount++;
  const reason = `小说 ${spending.novel_id} 没有作者`;
  skippedReasons.push(reason);
  console.warn(`[author-royalty/generate] ${reason}，跳过 reader_spending.id=${spending.id}`);
  continue; // ⚠️ 跳过这条记录
}
```

**跳过条件**：
- ❌ `novel` 不存在（`novels.length === 0`）
- ❌ `novel.user_id` 为 `NULL`（`!novels[0].user_id`）

### 3. INSERT 语句

```javascript
await db.execute(
  `INSERT INTO author_royalty 
   (author_id, novel_id, source_spend_id, gross_amount_usd, author_amount_usd, settlement_month)
   VALUES (?, ?, ?, ?, ?, ?)`,
  [
    authorId,                    // BIGINT
    spending.novel_id,           // BIGINT
    spending.id,                 // BIGINT (reader_spending.id)
    grossAmountUsd.toNumber(),   // DECIMAL(20,8)
    authorAmountUsd.toNumber(),  // DECIMAL(20,8)
    settlementMonth              // DATE ('2025-11-01')
  ]
);
```

**列名列表**：
1. `author_id` - 作者用户ID
2. `novel_id` - 小说ID
3. `source_spend_id` - 对应的 reader_spending.id
4. `gross_amount_usd` - 作品总收入（美元）
5. `author_amount_usd` - 给作者的部分（美元）
6. `settlement_month` - 结算月份（DATE 类型）

**表结构**：
- `id` - 自增主键（不需要插入）
- `created_at` - 默认值 CURRENT_TIMESTAMP（不需要插入）

### 4. 错误处理

```javascript
for (const spending of spendings) {
  try {
    // ... 处理逻辑
    await db.execute(INSERT ...);
    generatedCount++;
  } catch (insertError) {
    // ⚠️ 如果单条记录插入失败，记录错误但继续处理下一条
    skippedCount++;
    const reason = `插入失败: ${insertError.message}`;
    skippedReasons.push(`reader_spending.id=${spending.id}: ${reason}`);
    console.error(`[author-royalty/generate] reader_spending.id=${spending.id} 插入失败:`, insertError);
    // 继续处理下一条记录，不中断整个流程
  }
}
```

**错误处理说明**：
- ✅ 单条记录插入失败不会中断整个流程
- ✅ 错误会被记录到 `skippedReasons` 数组
- ✅ 错误会输出到控制台日志
- ✅ 最终返回结果会包含 `skipped` 数量和 `skippedReasons`

---

## 三、调试日志说明

### 1. 生成前的日志

```
[author-royalty/generate] month: 2025-11 settlementMonth: 2025-11-01
[author-royalty/generate] spendings count: 1
```

### 2. 处理过程中的日志

**如果跳过记录**：
```
[author-royalty/generate] 小说 7 没有作者，跳过 reader_spending.id=303
```

**如果插入失败**：
```
[author-royalty/generate] reader_spending.id=303 插入失败: Error: ...
```

### 3. 生成后的日志

**成功生成**：
```
[author-royalty/generate] generated rows: 1
```

**有跳过记录**：
```
[author-royalty/generate] generated rows: 0
[author-royalty/generate] skipped rows: 1 reasons: ['小说 7 没有作者']
```

---

## 四、排查步骤

### Step 1: 检查后端服务器日志

查看后端服务器控制台输出，查找以下日志：
- `[author-royalty/generate] month: ...`
- `[author-royalty/generate] spendings count: ...`
- `[author-royalty/generate] generated rows: ...`
- `[author-royalty/generate] skipped rows: ...`

### Step 2: 运行调试脚本

```bash
node backend/debug_author_royalty_generation.js
```

这个脚本会：
- ✅ 检查 reader_spending 数据是否存在
- ✅ 检查 novel 表的作者ID
- ✅ 检查是否已经生成过 author_royalty
- ✅ 模拟生成过程（不实际插入）

### Step 3: 检查数据库

**检查 reader_spending**：
```sql
SELECT id, novel_id, amount_usd, source_type, settlement_month
FROM reader_spending
WHERE settlement_month = '2025-11-01';
```

**检查 novel**：
```sql
SELECT id, user_id, title
FROM novel
WHERE id IN (SELECT DISTINCT novel_id FROM reader_spending WHERE settlement_month = '2025-11-01');
```

**检查 author_royalty**：
```sql
SELECT id, author_id, novel_id, gross_amount_usd, author_amount_usd, settlement_month
FROM author_royalty
WHERE settlement_month = '2025-11-01';
```

### Step 4: 检查前端调用

打开浏览器开发者工具（F12），查看 Network 标签：
- 找到 `POST /api/admin/author-royalty/generate` 请求
- 查看 Request Payload：`{ "month": "2025-11" }`
- 查看 Response：成功/失败信息

---

## 五、常见问题

### Q1: 为什么生成后 author_royalty 表还是空的？

**可能原因**：
1. ❌ 后端服务器没有重启，代码没有生效
2. ❌ `novel.user_id` 为 `NULL`，所有记录都被跳过
3. ❌ INSERT 语句执行失败，但错误被 catch 捕获了
4. ❌ 该月份数据已存在，需要先删除

**解决方法**：
1. ✅ 重启后端服务器
2. ✅ 检查后端服务器日志中的错误信息
3. ✅ 运行调试脚本：`node backend/debug_author_royalty_generation.js`
4. ✅ 检查数据库中的 `novel.user_id` 是否有值

### Q2: 为什么有些记录被跳过了？

**跳过条件**：
- `novel` 不存在
- `novel.user_id` 为 `NULL`

**解决方法**：
- 检查 `novel` 表，确保对应的 `novel.user_id` 有值

### Q3: 如何查看详细的错误信息？

**方法1：查看后端服务器日志**
- 查找 `[author-royalty/generate]` 开头的日志
- 查找 `插入失败` 或 `跳过` 的日志

**方法2：查看前端响应**
- 打开浏览器开发者工具（F12）
- 查看 Network 标签中的 API 响应
- 响应中的 `skippedReasons` 字段会包含跳过原因

---

## 六、根据调试脚本的结果

根据刚才运行的调试脚本，结果显示：

✅ **reader_spending 有数据**：1 条记录（id=303, novel_id=7）
✅ **novel 有作者**：novel_id=7, user_id=1
✅ **没有已存在的记录**：author_royalty 表为空
✅ **理论上应该可以生成**

**如果仍然无法生成，请检查**：
1. 后端服务器是否已重启（代码是否生效）
2. 后端服务器日志中是否有错误信息
3. 前端调用 API 时是否返回了错误

---

**文档生成时间**：2025-11-29
**代码位置**：`backend/routes/admin.js` 第 2288-2467 行

