# 编辑基础收入生成逻辑现状梳理报告

**生成时间**：2025-12-01  
**分析目标**：全面梳理 `editor_income_monthly`（编辑基础收入）生成逻辑的现状，包括代码流程、数据库结构和2025-10月实际数据情况

---

## 一、相关代码位置

### 1.1 路由入口

**文件路径**：`backend/routes/admin.js`  
**路由URL**：`POST /api/admin/editor-base-income/generate`  
**行号**：第 9484-9523 行

**关键代码**：
```javascript
const { generateEditorBaseIncomeForMonth } = require('../services/editorBaseIncomeService');

router.post('/editor-base-income/generate', authenticateAdmin, async (req, res) => {
  // 权限检查：只有 super_admin 或 finance 可以生成
  const { month } = req.body; // 'YYYY-MM' 格式
  const result = await generateEditorBaseIncomeForMonth(month);
  // 返回生成结果
});
```

### 1.2 Service 层

**文件路径**：`backend/services/editorBaseIncomeService.js`  
**主要类**：`EditorBaseIncomeService`  
**主要函数**：`generateEditorBaseIncomeForMonth(month)`

**其他相关函数**：
- `loadChapterUnlockContext(db, chapterUnlockSpendings)` - 加载章节解锁上下文
- `loadSubscriptionChapterStats(db, subscriptionSpendings)` - 加载订阅章节统计
- `loadNovelRoleContracts(db, spendings)` - 加载合同
- `generateFromChapterUnlock(...)` - 从章节解锁生成明细
- `generateFromSubscription(...)` - 从订阅生成明细
- `batchInsertEditorIncome(db, rows)` - 批量插入

---

## 二、当前生成流程（代码逻辑说明）

### 2.1 主流程（generateEditorBaseIncomeForMonth）

**伪代码流程**：

```javascript
async function generateEditorBaseIncomeForMonth(month) {
  // 1. 准备
  const settlementMonth = `${month}-01`; // '2025-10-01'
  
  // 2. 清空当月旧数据
  DELETE FROM editor_income_monthly WHERE month = settlementMonth;
  
  // 3. 查询当月所有 reader_spending
  SELECT id, novel_id, amount_usd, source_type, source_id, spend_time
  FROM reader_spending
  WHERE settlement_month = settlementMonth
  ORDER BY spend_time;
  
  // 4. 按 source_type 分类
  const chapterUnlockSpendings = spendings.filter(s => s.source_type === 'chapter_unlock');
  const subscriptionSpendings = spendings.filter(s => s.source_type === 'subscription');
  
  // 5. 预加载章节解锁上下文（章节解锁用）
  const chapterUnlockContext = await loadChapterUnlockContext(chapterUnlockSpendings);
  // 返回：{ unlockMap: Map<unlockId, chapterId>, chapterMap: Map<chapterId, chapterInfo> }
  
  // 6. 预加载订阅章节统计（订阅用）
  const subscriptionChapterStats = await loadSubscriptionChapterStats(subscriptionSpendings);
  // 返回：Map<novelId, { totalWordCount, editorWordMap, chiefWordMap, ... }>
  
  // 7. 预加载合同（所有 spending 共用）
  const novelContracts = await loadNovelRoleContracts(spendings);
  // 返回：Map<novelId, { editorContract, chiefContract }>
  
  // 8. 逐条处理章节解锁 spending，生成明细
  const rows = [];
  await generateFromChapterUnlock(rows, chapterUnlockSpendings, ...);
  
  // 9. 逐条处理订阅 spending，生成明细
  await generateFromSubscription(rows, subscriptionSpendings, ...);
  
  // 10. 批量插入 editor_income_monthly
  await batchInsertEditorIncome(db, rows);
  
  // 11. 提交事务
  commit();
}
```

### 2.2 章节解锁上下文加载（loadChapterUnlockContext）

**功能**：为章节解锁类型的 spending 预加载章节信息

**SQL 查询**：

```sql
-- 步骤1：查询 chapter_unlocks
SELECT id, chapter_id
FROM chapter_unlocks
WHERE id IN (unlockIds);

-- 步骤2：查询 chapter（计算有效字数）
SELECT
  id,
  novel_id,
  editor_admin_id,
  chief_editor_admin_id,
  review_status,
  word_count,
  CASE
    WHEN (word_count IS NULL OR word_count = 0) THEN
      CHAR_LENGTH(content)
    ELSE
      word_count
  END AS effective_word_count
FROM chapter
WHERE id IN (chapterIds);
```

**返回结构**：
- `unlockMap`: `Map<chapter_unlocks.id, chapter.id>`
- `chapterMap`: `Map<chapter.id, { novel_id, editor_admin_id, chief_editor_admin_id, review_status, effective_word_count }>`

### 2.3 订阅章节统计加载（loadSubscriptionChapterStats）

**功能**：为订阅类型的 spending 预加载所有已审核章节的字数统计

**SQL 查询**：

```sql
SELECT
  id,
  novel_id,
  editor_admin_id,
  chief_editor_admin_id,
  review_status,
  CASE
    WHEN (word_count IS NULL OR word_count = 0) THEN
      CHAR_LENGTH(content)
    ELSE
      word_count
  END AS effective_word_count
FROM chapter
WHERE novel_id IN (novelIds)
  AND review_status = 'approved'
```

**返回结构**：
```javascript
Map<novelId, {
  totalWordCount: number,           // 总字数
  totalChapterCount: number,        // 总章节数
  editorWordMap: Map<editorId, wordCount>,      // 编辑字数统计
  editorChapterCountMap: Map<editorId, count>, // 编辑章节数统计
  chiefWordMap: Map<chiefId, wordCount>,       // 主编字数统计
  chiefChapterCountMap: Map<chiefId, count>    // 主编章节数统计
}>
```

### 2.4 合同加载（loadNovelRoleContracts）⚠️ 关键

**功能**：加载所有相关小说的 active 合同

**SQL 查询**：

```sql
SELECT
  id,
  novel_id,
  editor_admin_id,
  role,
  share_type,
  share_percent,
  status,
  start_date,
  end_date
FROM novel_editor_contract
WHERE novel_id IN (novelIds)
  AND share_type = 'percent_of_book'
  AND status = 'active'
ORDER BY novel_id, role, start_date DESC, id DESC
```

**⚠️ 重要发现**：
- **代码中没有检查 `start_date` 和 `end_date`！**
- 只检查了 `share_type = 'percent_of_book'` 和 `status = 'active'`
- 这意味着即使合同的 `start_date` 在结算月之后，也会被选中

**返回结构**：
```javascript
Map<novelId, {
  editorContract: contract | null,  // 编辑合同（每个小说只取第一条）
  chiefContract: contract | null     // 主编合同（每个小说只取第一条）
}>
```

**分组逻辑**：
- 按 `novel_id + role` 分组
- 每个组合取第一条（按 `start_date DESC, id DESC` 排序）

### 2.5 章节解锁生成明细（generateFromChapterUnlock）

**处理逻辑**：

```javascript
for (const spending of chapterUnlockSpendings) {
  // 1. 根据 source_id 找到 chapter_unlocks -> chapter
  const chapterId = unlockMap.get(spending.source_id);
  const chapter = chapterMap.get(chapterId);
  
  // 2. 从 novelContracts 取出合同
  const nc = novelContracts.get(spending.novel_id);
  const editorContract = nc?.editorContract || null;
  const chiefContract = nc?.chiefContract || null;
  
  // 3. 如果有 editor_admin_id 且有 editorContract，生成编辑收入
  if (chapter.editor_admin_id && editorContract) {
    const income = amount_usd × editorContract.share_percent;
    rows.push({
      editor_admin_id: chapter.editor_admin_id,
      role: 'editor',
      novel_id: spending.novel_id,
      month: settlementMonth,
      source_type: 'chapter_unlock',
      source_spend_id: spending.id,
      chapter_id: chapterId,
      // ... 其他字段
    });
  } else if (chapter.editor_admin_id && !editorContract) {
    console.warn(`小说 ${spending.novel_id} 没有编辑角色合同`);
  }
  
  // 4. 如果有 chief_editor_admin_id 且有 chiefContract，生成主编收入
  if (chapter.chief_editor_admin_id && chiefContract) {
    // 类似逻辑
  } else if (chapter.chief_editor_admin_id && !chiefContract) {
    console.warn(`小说 ${spending.novel_id} 没有主编角色合同`);
  }
}
```

**关键点**：
- 每条 `reader_spending` 最多生成 2 条 `editor_income_monthly` 记录（编辑 + 主编）
- 如果章节有编辑/主编，但没有对应角色的合同，会记录 warning 日志，**不生成记录**

### 2.6 订阅生成明细（generateFromSubscription）

**处理逻辑**：

```javascript
for (const spending of subscriptionSpendings) {
  // 1. 获取该小说的章节统计
  const stats = subscriptionChapterStats.get(spending.novel_id);
  
  // 2. 如果有 editorContract，对所有有字数的编辑进行分配
  if (editorContract) {
    for (const [editorId, editorWordCount] of stats.editorWordMap.entries()) {
      const wordRatio = editorWordCount / stats.totalWordCount;
      const income = amount_usd × editorContract.share_percent × wordRatio;
      rows.push({
        editor_admin_id: editorId,
        role: 'editor',
        // ... 其他字段
      });
    }
  }
  
  // 3. 如果有 chiefContract，对所有有字数的主编进行分配
  // 类似逻辑
}
```

**关键点**：
- 按字数比例分配：`income = amount_usd × share_percent × (该编辑字数 / 总字数)`
- 每个有字数的编辑/主编都会生成一条记录

### 2.7 批量插入（batchInsertEditorIncome）

**SQL 语句**：

```sql
INSERT INTO editor_income_monthly
  (editor_admin_id, role, novel_id, month, source_spend_id, source_type, chapter_id,
   chapter_count_total, chapter_count_editor, total_word_count, editor_word_count,
   gross_book_income_usd, editor_share_percent, contract_share_percent, editor_income_usd)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  ...
```

**批量大小**：每批 500 条

---

## 三、涉及表结构摘要

### 3.1 reader_spending（读者消费汇总表）

**主键**：`id` (BIGINT AUTO_INCREMENT)

**关键字段**：
- `id`: 主键
- `user_id`: 读者用户ID
- `novel_id`: 小说ID
- `karma_amount`: 消费使用的karma数量
- `amount_usd`: 换算后的美元金额（DECIMAL(20,8)）
- `source_type`: 来源类型（ENUM: 'chapter_unlock', 'subscription'）
- `source_id`: 对应 `chapter_unlocks.id` 或 `user_champion_subscription_record.id`
- `spend_time`: 消费时间（DATETIME）
- `settlement_month`: 结算月份（DATE，格式：'2025-10-01'）
- `settled`: 是否已结算（TINYINT，默认0）

**索引**：
- `UNIQUE KEY uniq_source` (`source_type`, `source_id`)
- `KEY idx_month_settled` (`settlement_month`, `settled`)

### 3.2 chapter_unlocks（章节解锁表）

**主键**：`id` (INT AUTO_INCREMENT)

**关键字段**：
- `id`: 主键（对应 `reader_spending.source_id`，当 `source_type='chapter_unlock'` 时）
- `user_id`: 读者用户ID
- `chapter_id`: 章节ID（关联 `chapter.id`）
- `unlock_method`: 解锁方式（ENUM: 'free', 'key', 'karma', 'subscription', ...）
- `cost`: 实际花费的钥匙或业力数量
- `unlocked_at`: 解锁时间（DATETIME）

**索引**：
- `UNIQUE KEY unique_user_chapter` (`user_id`, `chapter_id`)
- `KEY chapter_id` (`chapter_id`)

### 3.3 chapter（章节表）

**主键**：`id` (INT AUTO_INCREMENT)

**关键字段**：
- `id`: 主键
- `novel_id`: 小说ID
- `editor_admin_id`: 负责审核该章节的编辑（INT，可为NULL）
- `chief_editor_admin_id`: 最终审核该章节的主编ID（INT，可为NULL）
- `word_count`: 字数（INT，可为NULL）
- `content`: 章节内容（LONGTEXT，用于计算字数）
- `review_status`: 审核状态（ENUM: 'submitted', 'reviewing', 'approved', 'rejected', 'draft', 'pending_chief'）
- `is_released`: 是否已发布（TINYINT(1)）

**索引**：
- `KEY novel_id` (`novel_id`)
- `KEY idx_chapter_editor_admin_id` (`editor_admin_id`)
- `KEY idx_chapter_chief_editor_admin_id` (`chief_editor_admin_id`)

### 3.4 novel_editor_contract（小说编辑合同表）

**主键**：`id` (INT AUTO_INCREMENT)

**关键字段**：
- `id`: 主键
- `novel_id`: 小说ID
- `editor_admin_id`: 编辑管理员ID（关联 `admin.id`）
- `role`: 编辑角色（ENUM: 'chief_editor', 'editor', 'proofreader'）
- `share_type`: 分成类型（ENUM: 'percent_of_book', 'percent_of_author'）
- `share_percent`: 分成比例（DECIMAL(8,4)，例如：0.0300 = 3%）
- `start_chapter_id`: 起始章节ID（INT，可为NULL）
- `end_chapter_id`: 结束章节ID（INT，可为NULL）
- `start_date`: 合同开始时间（DATETIME）
- `end_date`: 合同结束时间（DATETIME，可为NULL）
- `status`: 合同状态（ENUM: 'active', 'ended', 'cancelled'）

**索引**：
- `KEY idx_novel_id` (`novel_id`)
- `KEY idx_editor_admin_id` (`editor_admin_id`)
- `KEY idx_status` (`status`)

### 3.5 editor_income_monthly（编辑收入月度表）

**主键**：`id` (INT AUTO_INCREMENT)

**完整字段列表**（基于迁移文件 `20251129_fix_editor_income_monthly_unique_constraint.sql`）：

- `id`: 主键
- `editor_admin_id`: 编辑管理员ID（INT NOT NULL）
- `role`: 角色（ENUM: 'chief_editor', 'editor', 'proofreader'）
- `novel_id`: 小说ID（INT NOT NULL）
- `month`: 结算月份（DATE NOT NULL，格式：'2025-10-01'）
- `source_spend_id`: 对应 `reader_spending.id`（BIGINT，可为NULL）✅ 新增字段
- `source_type`: 收入来源类型（ENUM: 'chapter_unlock', 'subscription', 'mixed'）
- `chapter_id`: 对应章节ID（INT，可为NULL）✅ 新增字段（source_type='chapter_unlock'时使用）
- `chapter_count_total`: 该小说当期用于分配的总章节数（INT，默认0）
- `chapter_count_editor`: 该编辑审核的章节数（INT，默认0）
- `total_word_count`: 本次分配使用的总字数（INT，默认0）✅ 新增字段
- `editor_word_count`: 本次分配中该编辑负责的字数（INT，默认0）✅ 新增字段
- `gross_book_income_usd`: 作品总收入（DECIMAL(18,6)，默认0）
- `editor_share_percent`: 编辑实际生效的分成比例（DECIMAL(8,4)，默认0）
- `contract_share_percent`: 从合同取到的基础分成比例（DECIMAL(8,4)，可为NULL）
- `editor_income_usd`: 编辑收入（DECIMAL(18,6)，默认0）
- `created_at`: 创建时间（DATETIME，默认CURRENT_TIMESTAMP）
- `updated_at`: 更新时间（DATETIME，默认CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP）

**索引**：
- `KEY idx_editor_admin_id` (`editor_admin_id`)
- `KEY idx_novel_id` (`novel_id`)
- `KEY idx_month` (`month`)
- `KEY idx_month_source_spend` (`month`, `source_spend_id`) ✅ 新增索引
- `KEY idx_source_spend_id` (`source_spend_id`) ✅ 新增索引
- `KEY idx_chapter_id` (`chapter_id`) ✅ 新增索引

**⚠️ 注意**：唯一约束 `uniq_editor_month_novel` 已被删除，现在允许同一编辑+小说+月份有多条记录

---

## 四、2025-10 数据检查结果

### 4.1 调试脚本

已创建调试脚本：`backend/debug_editor_income_2025_10.js`

**使用方法**：
```bash
node backend/debug_editor_income_2025_10.js
```

**脚本功能**：
1. 检查 `reader_spending` 数据（按 `source_type` 统计）
2. 检查章节解锁链路（`reader_spending` -> `chapter_unlocks` -> `chapter`）
3. 检查 `novel_editor_contract` 合同（包括所有状态和 active 状态）
4. 检查 `editor_income_monthly` 现有数据
5. 分析问题原因

### 4.2 预期查询结果（需要运行脚本后获取）

**reader_spending 分布**：
```sql
SELECT 
  COUNT(*) AS total,
  SUM(amount_usd) AS total_amount_usd,
  source_type
FROM reader_spending
WHERE settlement_month = '2025-10-01'
GROUP BY source_type;
```

**章节解锁链路示例**：
```
reader_spending.id = X
  -> chapter_unlocks.id = Y (source_id)
    -> chapter.id = Z (chapter_id)
      -> novel_id = N
        -> editor_admin_id = E
        -> chief_editor_admin_id = C
```

**合同检查**：
```sql
SELECT *
FROM novel_editor_contract
WHERE novel_id IN (涉及的小说ID列表)
ORDER BY novel_id, role, status, start_date DESC;
```

### 4.3 问题分析

根据代码逻辑，日志显示"编辑合同=0, 主编合同=0"的可能原因：

1. **这些小说确实没有 active 状态的合同**
   - 检查 `novel_editor_contract` 表中是否有 `status='active'` 的记录

2. **合同存在但 `share_type` 不是 `'percent_of_book'`**
   - 代码只查询 `share_type = 'percent_of_book'` 的合同

3. **合同存在但 `status` 不是 `'active'`**
   - 代码只查询 `status = 'active'` 的合同

4. **⚠️ 日期问题（代码中没有检查，但可能影响业务逻辑）**
   - 代码**没有检查 `start_date` 和 `end_date`**
   - 如果合同的 `start_date = '2025-11-29'`，而结算月是 `'2025-10-01'`，代码仍然会选中该合同
   - 但业务上可能认为该合同在 2025-10 时还未生效

**关键代码位置**：`backend/services/editorBaseIncomeService.js` 第 314-331 行

```javascript
const [contracts] = await db.execute(
  `SELECT ... FROM novel_editor_contract
   WHERE novel_id IN (?)
     AND share_type = 'percent_of_book'
     AND status = 'active'
   ORDER BY novel_id, role, start_date DESC, id DESC`,
  [novelIds]
);
```

**缺少的过滤条件**：
- ❌ 没有检查 `start_date <= settlementMonth`
- ❌ 没有检查 `end_date IS NULL OR end_date >= settlementMonth`
- ❌ 没有检查 `start_chapter_id` 和 `end_chapter_id`（章节范围）

---

## 五、初步结论 / 疑点

### 5.1 合同查询逻辑问题

**现状**：
- 代码只检查 `share_type = 'percent_of_book'` 和 `status = 'active'`
- **没有检查日期范围**（`start_date` / `end_date`）
- **没有检查章节范围**（`start_chapter_id` / `end_chapter_id`）

**可能的问题**：
1. 如果 2025-10 时，某些小说的合同 `start_date` 在 2025-11 或更晚，代码仍然会选中这些合同
2. 如果合同在 2025-10 时还未生效（`start_date > '2025-10-01'`），业务上不应该使用该合同，但代码会使用

### 5.2 2025-10 数据缺失的可能原因

根据日志：
```
[editor-base-income] 合同加载: 小说数=5, 编辑合同=0, 主编合同=0
[editor-base-income] 章节解锁生成明细: 0 条
[editor-base-income] 订阅生成明细: 0 条
[editor-base-income] 生成完成: 插入 0 条记录
```

**可能原因**：
1. **这些小说确实没有 active 合同**
   - 需要运行调试脚本确认

2. **合同存在但 `share_type` 不是 `'percent_of_book'`**
   - 需要检查合同表的 `share_type` 字段

3. **合同存在但 `status` 不是 `'active'`**
   - 需要检查合同表的 `status` 字段

4. **章节没有 `editor_admin_id` 或 `chief_editor_admin_id`**
   - 需要检查章节表的编辑归属字段

### 5.3 建议的修复方向

1. **在合同查询中添加日期过滤**：
   ```sql
   WHERE novel_id IN (?)
     AND share_type = 'percent_of_book'
     AND status = 'active'
     AND start_date <= ?  -- 结算月必须 >= 合同开始日期
     AND (end_date IS NULL OR end_date >= ?)  -- 结算月必须 <= 合同结束日期（如果有）
   ```

2. **考虑章节范围过滤**（如果需要）：
   ```sql
   AND (start_chapter_id IS NULL OR start_chapter_id <= ?)
   AND (end_chapter_id IS NULL OR end_chapter_id >= ?)
   ```

3. **添加更详细的日志**：
   - 记录每个小说查询到的合同数量
   - 记录被过滤掉的合同及原因

---

## 六、下一步行动建议

1. **运行调试脚本**：`node backend/debug_editor_income_2025_10.js`
   - 获取 2025-10 的实际数据情况
   - 确认合同是否存在以及状态

2. **检查合同数据**：
   - 确认涉及的小说是否有 active 合同
   - 确认合同的 `start_date` 是否在 2025-10 之前

3. **根据实际数据决定修复方案**：
   - 如果合同确实不存在 → 需要创建合同
   - 如果合同存在但日期不对 → 需要修改合同查询逻辑
   - 如果合同存在但其他字段不对 → 需要修改合同数据或查询逻辑

---

**报告结束**

**附件**：
- 调试脚本：`backend/debug_editor_income_2025_10.js`
- 主要代码文件：`backend/services/editorBaseIncomeService.js`
- 路由文件：`backend/routes/admin.js`（第 9484-9653 行）

