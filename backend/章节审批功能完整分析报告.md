# 章节审批功能完整分析报告

**生成时间**：2025-12-01  
**分析目标**：全面摸清「章节审批」功能的现状实现，重点关注权限控制、字段更新逻辑和前端按钮控制

---

## 一、涉及文件一览

### 1.1 后端文件

#### 路由层
- **`backend/routes/admin.js`** (第 8574-9040 行)
  - `GET /api/admin/chapters` - 获取章节列表（分页+筛选+搜索）
  - `GET /api/admin/chapter/:id` - 获取章节详情（包含 can_review 计算）
  - `POST /api/admin/chapter/review` - 审核章节（统一接口）
  - `POST /api/admin/chapters/batch-review` - 批量审核章节

#### 控制器层
- **`backend/controllers/chapterReviewController.js`**
  - `ChapterReviewController` 类
  - `reviewChapter(req, res)` - 处理单个章节审核请求
  - `batchReviewChapters(req, res)` - 处理批量审核请求

#### 服务层
- **`backend/services/chapterReviewService.js`**
  - `ChapterReviewService` 类
  - `reviewChapter(currentAdmin, params)` - 核心审核逻辑
  - `canCurrentAdminOverrideEditor(db, chapter, adminId, adminRole)` - 判断是否可以覆盖 editor_admin_id
  - `hasActiveChiefContract(db, novelId, chiefEditorAdminId)` - 检查主编是否有有效合同
  - `getChapterById(chapterId)` - 获取章节信息
  - `getNovelById(novelId)` - 获取小说信息

#### 权限中间件
- **`backend/middleware/permissionMiddleware.js`**
  - `getNovelPermissionFilter(db, adminId, role)` - 生成小说查询的 WHERE 条件
  - `checkNovelPermission(db, adminId, role, novelId)` - 检查是否有权限访问小说
  - `hasActiveContract(db, novelId, adminId, role)` - 检查是否有有效合同
  - `checkRequiresChiefEdit(db, novel)` - 检查是否需要主编终审
  - `computeChapterCanReview(db, admin, chapter, novel)` - **统一计算章节审核权限**

### 1.2 前端文件

#### 主入口组件
- **`frontend/src/pages/AdminPanel/ChapterApproval/index.tsx`**
  - `ChapterApproval` 组件 - 章节审批页面主入口
  - 从 localStorage 解码 JWT token 获取当前管理员角色
  - 调用 `GET /api/admin/chapters` 加载章节列表
  - 调用 `GET /api/admin/chapter/:id` 加载章节详情
  - 调用 `POST /api/admin/chapter/review` 执行审核操作

#### 详情组件
- **`frontend/src/pages/AdminPanel/ChapterApproval/ChapterDetail.tsx`**
  - `ChapterDetail` 组件 - 展示章节详情和三个审核按钮
  - `canApprove()` - 判断"审核通过"按钮是否可用
  - `getApproveButtonText()` - 根据角色和状态返回按钮文本
  - `handleReview(result)` - 处理审核操作

#### 列表组件
- **`frontend/src/pages/AdminPanel/ChapterApproval/ChapterList.tsx`**
  - `ChapterList` 组件 - 展示章节列表表格

---

## 二、后端章节审核流程总览

### 2.1 审核入口：POST /api/admin/chapter/review

**调用链**：
```
router.post('/chapter/review')
  ↓
ChapterReviewController.reviewChapter()
  ↓
  1. 参数验证（chapter_id, result, comment）
  2. 角色验证（必须是 editor/chief_editor/super_admin）
  3. 检查章节是否存在
  4. checkNovelPermission() - 检查是否有有效合同
  ↓
ChapterReviewService.reviewChapter()
  ↓
  核心审核逻辑（见下文）
```

### 2.2 权限检查流程

#### 2.2.1 Controller 层的权限检查

**位置**：`backend/controllers/chapterReviewController.js` 第 55-65 行

```javascript
// 检查权限
db = await this.service.createConnection();
const hasPermission = await checkNovelPermission(
  db,
  adminId,
  role,
  chapter.novel_id
);
await db.end();

if (!hasPermission) {
  return res.status(403).json({ success: false, message: '无权限审核此章节' });
}
```

**`checkNovelPermission` 逻辑**（`permissionMiddleware.js` 第 57-110 行）：
1. 检查小说是否存在
2. 根据角色确定需要检查的合同类型：
   - `editor` → 需要 `role='editor'` 的合同
   - `chief_editor` → 需要 `role='chief_editor'` 的合同
   - `super_admin` → 可以拥有 `role='editor'` 或 `role='chief_editor'` 的合同
3. 查询 `novel_editor_contract` 表，检查是否有有效合同：
   - `novel_id = ?`
   - `editor_admin_id = ?` (当前管理员ID)
   - `role IN (?)` (根据角色确定)
   - `status = 'active'`
   - `start_date <= NOW()`
   - `(end_date IS NULL OR end_date >= NOW())`

**注意**：`checkNovelPermission` 不区分 `super_admin`，所有人（包括 super_admin）都必须有有效合同才能通过此检查。但实际在 `computeChapterCanReview` 中，`super_admin` 会提前返回 `true`。

#### 2.2.2 Service 层的审核逻辑

**位置**：`backend/services/chapterReviewService.js` 第 251-471 行

**核心流程**：

```javascript
async reviewChapter(currentAdmin, params) {
  // 1. 获取章节和小说信息
  const chapter = await this.getChapterById(chapter_id);
  const novel = await this.getNovelById(chapter.novel_id);
  
  // 2. 判断是否需要主编终审
  const requiresChief = await this.hasActiveChiefContract(
    db, 
    novel.id, 
    novel.chief_editor_admin_id
  );
  
  // 3. 根据 result 分支处理
  if (result === 'approved') {
    if (!requiresChief) {
      // 没有主编流程：直接 approved
    } else {
      if (adminRole === 'editor') {
        // 编辑审核 → pending_chief
      } else if (adminRole === 'chief_editor' || adminRole === 'super_admin') {
        // 主编/超管终审 → approved
      }
    }
  } else if (result === 'rejected') {
    // 拒绝逻辑
  } else if (result === 'reviewing') {
    // 保存为审核中
  }
}
```

---

## 三、editor_admin_id / chief_editor_admin_id 更新规则详解

### 3.1 更新规则总表

| 场景 | 当前审核人 | 章节状态 | editor_admin_id 更新规则 | chief_editor_admin_id 更新规则 |
|------|-----------|---------|-------------------------|------------------------------|
| **场景A：首次审核（editor_admin_id 为空）** |
| A1 | editor E | submitted/reviewing | ✅ 设置为 E | - |
| A2 | chief_editor C | submitted/reviewing | ❌ 不允许（主编不参与编辑阶段） | - |
| A3 | super_admin S | submitted/reviewing | ✅ 设置为 S | - |
| **场景B：已有 editor_admin_id = E1** |
| B1 | 同一个编辑 E1 | submitted/reviewing | ✅ 保持不变（允许自己再审） | - |
| B2 | 另一个编辑 E2 | submitted/reviewing | ❌ 不允许（抢功防护） | - |
| B3 | 主编 C | submitted/reviewing | ❌ 不允许（主编不参与编辑阶段） | - |
| B4 | super_admin S | submitted/reviewing | ✅ 覆盖为 S（超管可覆盖） | - |
| **场景C：已有 editor_admin_id = 超管 S** |
| C1 | 编辑 E | submitted/reviewing | ✅ 覆盖为 E（编辑可从超管接盘） | - |
| C2 | 主编 C | submitted/reviewing | ❌ 不允许（主编不参与编辑阶段） | - |
| C3 | super_admin S2 | submitted/reviewing | ✅ 覆盖为 S2（超管之间可覆盖） | - |
| **场景D：主编终审阶段（pending_chief）** |
| D1 | chief_editor C | pending_chief | ✅ 保持不变（如果已有值）<br>✅ 使用 novel.current_editor_admin_id（如果为空） | ✅ 设置为 C（如果为空） |
| D2 | super_admin S | pending_chief | ✅ 保持不变（如果已有值）<br>✅ 使用 novel.current_editor_admin_id（如果为空） | ✅ 设置为 novel.chief_editor_admin_id（如果为空） |
| D3 | editor E | pending_chief | ❌ 不允许（编辑不能终审） | - |

### 3.2 关键代码引用

#### 3.2.1 抢功防护逻辑

**位置**：`backend/services/chapterReviewService.js` 第 197-240 行

```javascript
async canCurrentAdminOverrideEditor(db, chapter, adminId, adminRole) {
  // 1. 如果章节没有 editor_admin_id，直接允许
  if (!chapter.editor_admin_id) {
    return { allowed: true };
  }

  // 2. 如果当前审核人就是原来的那个人，允许
  if (chapter.editor_admin_id === adminId) {
    return { allowed: true };
  }

  // 3. 如果当前审核人是超级管理员，允许覆盖
  if (adminRole === 'super_admin') {
    return { allowed: true };
  }

  // 4. 查询已有归属人的角色
  const [admins] = await db.execute(
    'SELECT role FROM admin WHERE id = ?',
    [chapter.editor_admin_id]
  );
  const existingRole = admins.length > 0 ? (admins[0].role || 'editor') : 'editor';

  // 5. 如果当前审核人是普通编辑（或类编辑角色）
  if (adminRole === 'editor' || adminRole === 'chief_editor') {
    // 如果之前是超管审批的，允许当前编辑重新审批并覆盖
    if (existingRole === 'super_admin') {
      return { allowed: true };
    }
    
    // 否则（之前是其他编辑审批的），不允许覆盖
    return {
      allowed: false,
      reason: '该章节已由其他编辑审核通过，不能再次修改责任编辑'
    };
  }

  return { allowed: false, reason: '当前账号无权修改该章节的责任编辑归属' };
}
```

**调用位置**：
- 编辑阶段审核通过时（第 308、342 行）
- 拒绝操作时（第 417 行，仅编辑阶段）
- "保存为审核中"操作时（第 441 行，仅编辑阶段）

**注意**：主编终审阶段（`pending_chief`）**不调用**此函数，直接保持 `editor_admin_id` 不变。

#### 3.2.2 没有主编流程时的更新逻辑

**位置**：`backend/services/chapterReviewService.js` 第 303-333 行

```javascript
if (!requiresChief) {
  // ✅ 没有主编：editor / super_admin 审核通过后直接变为 approved
  finalStatus = 'approved';
  
  // 检查是否可以覆盖 editor_admin_id
  const { allowed, reason } = await this.canCurrentAdminOverrideEditor(db, chapter, adminId, adminRole);
  if (!allowed) {
    throw new Error(reason || '当前账号无权修改该章节的责任编辑归属');
  }
  
  // 确定最终的 editor_admin_id
  let finalEditorId;
  if (adminRole === 'super_admin') {
    // 超级管理员：总是更新为当前审核人ID
    finalEditorId = adminId;
  } else if (adminRole === 'editor') {
    // 普通编辑：更新为当前审核人ID
    finalEditorId = adminId;
  } else {
    // 其他角色：使用小说的当前编辑ID
    finalEditorId = editorAdminId;
  }

  await db.execute(
    `UPDATE chapter SET 
     review_status = ?,
     reviewed_at = NOW(),
     editor_admin_id = ?
     WHERE id = ?`,
    [finalStatus, finalEditorId, chapter_id]
  );
}
```

#### 3.2.3 有主编流程：编辑审核通过

**位置**：`backend/services/chapterReviewService.js` 第 337-356 行

```javascript
if (adminRole === 'editor') {
  // 责任编辑审核通过 -> 等待主编终审
  finalStatus = 'pending_chief';
  
  // 检查是否可以覆盖 editor_admin_id
  const { allowed, reason } = await this.canCurrentAdminOverrideEditor(db, chapter, adminId, adminRole);
  if (!allowed) {
    throw new Error(reason || '当前账号无权修改该章节的责任编辑归属');
  }
  
  // 普通编辑：更新为当前审核人ID
  const finalEditorId = adminId;

  await db.execute(
    `UPDATE chapter SET 
     review_status = ?,
     editor_admin_id = ?
     WHERE id = ?`,
    [finalStatus, finalEditorId, chapter_id]
  );
}
```

#### 3.2.4 有主编流程：主编终审通过

**位置**：`backend/services/chapterReviewService.js` 第 358-399 行

```javascript
else if (adminRole === 'chief_editor' || adminRole === 'super_admin') {
  // 主编/有主编合同的 super_admin 终审通过 -> 最终 approved
  finalStatus = 'approved';
  
  // 防止抢功：如果章节已有主编归属，且不是当前审核人，则拒绝
  if (chapter.chief_editor_admin_id && chapter.chief_editor_admin_id !== adminId) {
    throw new Error('该章节已由其他主编审核通过，不能修改主编归属');
  }
  
  // 主编终审阶段：editor_admin_id 保持不变（如果已有值）
  // 如果为空，可以填小说级别 current_editor_admin_id，但不要用主编的 id 去覆盖
  let finalEditorId = chapter.editor_admin_id;
  if (!finalEditorId) {
    // 如果章节没有 editor_admin_id，使用小说的 current_editor_admin_id
    finalEditorId = editorAdminId;
  }
  // 注意：主编终审阶段不检查 editor_admin_id 覆盖规则，因为这是主编终审，不是编辑阶段
  
  // chief_editor_admin_id 设置规则：
  // 如果当前为 NULL：
  //   - adminRole = 'chief_editor' => 设置为当前 adminId
  //   - adminRole = 'super_admin' => 尝试设置为 novel.chief_editor_admin_id，如果也为空就保持 NULL
  // 如果已有值，则保持不变（不强制覆盖）
  let finalChiefEditorId = chapter.chief_editor_admin_id;
  if (!finalChiefEditorId) {
    if (adminRole === 'chief_editor') {
      finalChiefEditorId = adminId;
    } else if (adminRole === 'super_admin') {
      // super_admin 终审时，如果没有主编归属，设置为小说的主编（如果有）
      finalChiefEditorId = novel.chief_editor_admin_id || null;
    }
  }

  await db.execute(
    `UPDATE chapter SET 
     review_status = ?,
     reviewed_at = NOW(),
     editor_admin_id = COALESCE(?, editor_admin_id),
     chief_editor_admin_id = COALESCE(?, chief_editor_admin_id)
     WHERE id = ?`,
    [finalStatus, finalEditorId, finalChiefEditorId, chapter_id]
  );
}
```

**关键点**：
1. `editor_admin_id` 使用 `COALESCE(?, editor_admin_id)`，即：如果传入值不为 NULL 则更新，否则保持原值
2. `chief_editor_admin_id` 同样使用 `COALESCE`，只在为空时设置

#### 3.2.5 拒绝操作

**位置**：`backend/services/chapterReviewService.js` 第 406-431 行

```javascript
else if (result === 'rejected') {
  // 拒绝：仅更新状态，不写入归属信息
  // 主编终审阶段（pending_chief）只允许主编和超管操作，不检查 editor_admin_id 覆盖规则
  // 编辑阶段需要检查 editor_admin_id 覆盖规则
  if (chapter.review_status === 'pending_chief') {
    // 主编终审阶段：只允许主编和超管操作
    if (adminRole !== 'chief_editor' && adminRole !== 'super_admin') {
      throw new Error('主编终审阶段只能由主编或超级管理员操作');
    }
  } else {
    // 编辑阶段：检查 editor_admin_id 覆盖规则
    const { allowed, reason } = await this.canCurrentAdminOverrideEditor(db, chapter, adminId, adminRole);
    if (!allowed) {
      throw new Error(reason || '当前账号无权操作该章节');
    }
  }
  
  finalStatus = 'rejected';
  
  await db.execute(
    `UPDATE chapter SET 
     review_status = ?,
     reviewed_at = NOW()
     WHERE id = ?`,
    [finalStatus, chapter_id]
  );
}
```

**注意**：拒绝操作**不修改** `editor_admin_id` 和 `chief_editor_admin_id`。

#### 3.2.6 "保存为审核中"操作

**位置**：`backend/services/chapterReviewService.js` 第 433-451 行

```javascript
else if (result === 'reviewing') {
  // 标记为审核中（初审）
  // 主编终审阶段（pending_chief）不允许"保存为审核中"操作
  if (chapter.review_status === 'pending_chief') {
    throw new Error('主编终审阶段不能执行"保存为审核中"操作');
  }
  
  // 编辑阶段：检查 editor_admin_id 覆盖规则
  const { allowed, reason } = await this.canCurrentAdminOverrideEditor(db, chapter, adminId, adminRole);
  if (!allowed) {
    throw new Error(reason || '当前账号无权操作该章节');
  }
  
  finalStatus = 'reviewing';
  
  await db.execute(
    `UPDATE chapter SET review_status = ? WHERE id = ?`,
    [finalStatus, chapter_id]
  );
}
```

**注意**：此操作**不修改** `editor_admin_id` 和 `chief_editor_admin_id`，只更新 `review_status`。

---

## 四、can_review 计算逻辑详解

### 4.1 后端计算逻辑

**位置**：`backend/routes/admin.js` 第 8856-8894 行

**调用链**：
```
GET /api/admin/chapter/:id
  ↓
computeChapterCanReview(db, admin, chapter, novel)  // 基础权限计算
  ↓
在编辑阶段叠加 editor_admin_id 覆盖规则检查
```

#### 4.1.1 computeChapterCanReview 函数

**位置**：`backend/middleware/permissionMiddleware.js` 第 178-219 行

```javascript
async function computeChapterCanReview(db, admin, chapter, novel) {
  const { adminId, role: adminRole } = admin;
  
  // 1. super_admin 永远允许
  if (adminRole === 'super_admin') {
    return true;
  }
  
  // 2. 先判断有没有 active 合同（按角色分开）
  let hasContract = false;
  if (adminRole === 'editor') {
    hasContract = await hasActiveContract(db, novel.id, adminId, 'editor');
  } else if (adminRole === 'chief_editor') {
    hasContract = await hasActiveContract(db, novel.id, adminId, 'chief_editor');
  } else {
    // 其它角色暂不允许
    return false;
  }
  
  if (!hasContract) {
    return false;
  }
  
  // 3. 根据是否有主编流程 & 当前 review_status 决定
  const requiresChiefEdit = await checkRequiresChiefEdit(db, novel);
  const status = chapter.review_status;
  
  if (!requiresChiefEdit) {
    // 没有主编流程，只要有合同就可以审
    return true;
  }
  
  // 有主编流程：
  if (status === 'pending_chief') {
    // 等待主编终审阶段：只允许主编 / 超管，但 super_admin 已在上面提前 return
    return adminRole === 'chief_editor';
  } else {
    // 其它状态（submitted/reviewing/rejected...）只允许编辑和超管；
    // 这里 super_admin 已经提前 return true，主编不参与第一阶段编辑审核
    return adminRole === 'editor';
  }
}
```

#### 4.1.2 叠加 editor_admin_id 覆盖规则

**位置**：`backend/routes/admin.js` 第 8864-8894 行

```javascript
// 在编辑阶段（非 pending_chief），叠加"责任编辑覆盖规则"的判断
// 主编终审阶段（pending_chief）不检查 editor_admin_id 覆盖规则
if (canReview && chapter.review_status !== 'pending_chief') {
  // 如果章节没有 editor_admin_id，允许审核
  if (!chapter.editor_admin_id) {
    canReview = true;
  } else {
    // 查询已有归属人的角色
    const [existingAdmins] = await db.execute(
      'SELECT role FROM admin WHERE id = ?',
      [chapter.editor_admin_id]
    );
    const existingRole = existingAdmins.length > 0 ? (existingAdmins[0].role || 'editor') : 'editor';
    const currentAdminId = req.admin.adminId;
    const currentAdminRole = req.admin.role;
    
    if (chapter.editor_admin_id === currentAdminId) {
      // 自己永远可以再审
      canReview = true;
    } else if (currentAdminRole === 'super_admin') {
      // 超管永远可以
      canReview = true;
    } else if (existingRole === 'super_admin' && (currentAdminRole === 'editor' || currentAdminRole === 'chief_editor')) {
      // 之前是超管审的，现在是普通编辑 / 主编来审，也允许
      canReview = true;
    } else {
      // 之前是某个编辑 E1，当前是另一个编辑 E2，则不能审
      canReview = false;
    }
  }
}
```

**关键点**：
1. 此检查**只在编辑阶段**（`review_status !== 'pending_chief'`）生效
2. 主编终审阶段（`pending_chief`）**不检查** `editor_admin_id` 覆盖规则，直接使用 `computeChapterCanReview` 的结果

### 4.2 can_review 计算总结表

| 角色 | 是否有合同 | 是否有主编流程 | review_status | can_review 结果 | 说明 |
|------|-----------|--------------|---------------|----------------|------|
| super_admin | - | - | 任意 | ✅ true | 永远允许 |
| editor | ❌ 无 | - | 任意 | ❌ false | 必须有编辑合同 |
| editor | ✅ 有 | ❌ 无 | 任意 | ✅ true | 有合同即可 |
| editor | ✅ 有 | ✅ 有 | submitted/reviewing/rejected | ✅ true | 编辑阶段允许 |
| editor | ✅ 有 | ✅ 有 | pending_chief | ❌ false | 主编终审阶段不允许 |
| chief_editor | ❌ 无 | - | 任意 | ❌ false | 必须有主编合同 |
| chief_editor | ✅ 有 | ❌ 无 | 任意 | ✅ true | 有合同即可 |
| chief_editor | ✅ 有 | ✅ 有 | submitted/reviewing/rejected | ❌ false | 编辑阶段不允许 |
| chief_editor | ✅ 有 | ✅ 有 | pending_chief | ✅ true | 主编终审阶段允许 |

**叠加 editor_admin_id 覆盖规则后**（仅编辑阶段）：

| 当前审核人 | 已有 editor_admin_id | 已有归属人角色 | can_review 最终结果 |
|-----------|---------------------|---------------|-------------------|
| editor E1 | NULL | - | ✅ true |
| editor E1 | E1 | - | ✅ true（自己） |
| editor E2 | E1 | editor | ❌ false（抢功防护） |
| editor E2 | S | super_admin | ✅ true（可从超管接盘） |
| chief_editor C | E1 | editor | ❌ false（主编不参与编辑阶段） |
| super_admin S | E1 | editor | ✅ true（超管可覆盖） |

---

## 五、前端按钮禁用逻辑

### 5.1 三个按钮的 disabled 条件

#### 5.1.1 「保存为审核中」按钮

**位置**：`frontend/src/pages/AdminPanel/ChapterApproval/ChapterDetail.tsx` 第 375-381 行

```typescript
<button
  onClick={() => handleReview('reviewing')}
  disabled={saving || chapter.review_status === 'reviewing' || chapter.review_status === 'pending_chief' || !chapter.can_review}
  className={styles.saveBtn}
>
  保存为"审核中"
</button>
```

**disabled 条件**：
1. `saving` - 正在保存中
2. `chapter.review_status === 'reviewing'` - 已经是"审核中"状态
3. `chapter.review_status === 'pending_chief'` - 主编终审阶段不允许此操作
4. `!chapter.can_review` - 没有审核权限

#### 5.1.2 「审核通过 / 提交主编终审 / 终审通过」按钮

**位置**：`frontend/src/pages/AdminPanel/ChapterApproval/ChapterDetail.tsx` 第 382-388 行

```typescript
<button
  onClick={() => handleReview('approved')}
  disabled={saving || !canApprove() || !chapter.can_review}
  className={styles.approveBtn}
>
  {getApproveButtonText()}
</button>
```

**disabled 条件**：
1. `saving` - 正在保存中
2. `!canApprove()` - 业务逻辑不允许（见下文）
3. `!chapter.can_review` - 没有审核权限

**`canApprove()` 函数逻辑**（第 110-128 行）：

```typescript
const canApprove = () => {
  const status = chapter.review_status;
  
  if (!requiresChiefEdit) {
    // 没有主编流程：有合同即可审；
    // 具体谁能覆盖 editor_admin_id 已经在后端控制，这里只放行 editor 和 super_admin
    return isEditor || isSuperAdmin;
  }
  
  // 有主编流程：
  if (status === 'pending_chief') {
    // 等待主编终审阶段：只允许主编和超管点"通过/拒绝"
    return isChiefEditor || isSuperAdmin;
  }
  
  // 其它状态（submitted/reviewing/rejected...）：是编辑阶段，只允许编辑和超管；
  // 主编不参与这一阶段的"通过"，但可以看。
  return isEditor || isSuperAdmin;
};
```

**`getApproveButtonText()` 函数逻辑**（第 87-106 行）：

```typescript
const getApproveButtonText = () => {
  if (!requiresChiefEdit) {
    // 不需要主编终审：直接显示"审核通过"
    return '审核通过';
  } else {
    // 需要主编终审
    if (isEditor) {
      // 编辑：显示"提交主编终审"
      return '提交主编终审';
    } else if (isChiefEditor || isSuperAdmin) {
      // 主编/超管：根据状态显示
      if (isPendingChief) {
        return '终审通过';
      } else {
        return '审核通过';
      }
    }
  }
  return '审核通过';
};
```

#### 5.1.3 「审核拒绝」按钮

**位置**：`frontend/src/pages/AdminPanel/ChapterApproval/ChapterDetail.tsx` 第 389-395 行

```typescript
<button
  onClick={() => handleReview('rejected')}
  disabled={saving || !reviewComment.trim() || !chapter.can_review}
  className={styles.rejectBtn}
>
  审核拒绝
</button>
```

**disabled 条件**：
1. `saving` - 正在保存中
2. `!reviewComment.trim()` - 审核备注为空（拒绝时必须填写备注）
3. `!chapter.can_review` - 没有审核权限

### 5.2 提示文案显示逻辑

**位置**：`frontend/src/pages/AdminPanel/ChapterApproval/ChapterDetail.tsx` 第 367-372 行

```typescript
{/* 如果没有审核权限，显示提示（super_admin 不显示此提示） */}
{chapter.can_review === false && currentAdminRole !== 'super_admin' && (
  <div className={styles.noReviewPermission}>
    <p>您当前在该小说上没有生效的编辑/主编合同，因此不能进行审核操作。</p>
  </div>
)}
```

**显示条件**：
1. `chapter.can_review === false` - 后端返回没有审核权限
2. `currentAdminRole !== 'super_admin'` - 不是超级管理员（super_admin 不显示此提示）

---

## 六、典型场景分析

### 场景 A：chapter.editor_admin_id 为空，首次审核通过

**当前审核人：editor E**

**代码路径**：`chapterReviewService.js` 第 303-333 行（无主编流程）或第 337-356 行（有主编流程）

**行为**：
- 无主编流程：`review_status = 'approved'`，`editor_admin_id = E`
- 有主编流程：`review_status = 'pending_chief'`，`editor_admin_id = E`

**代码引用**：
```javascript
// 无主编流程
const { allowed, reason } = await this.canCurrentAdminOverrideEditor(db, chapter, adminId, adminRole);
// allowed = true（因为 chapter.editor_admin_id 为空）
finalEditorId = adminId; // E
```

**当前审核人：chief_editor C**

**行为**：
- 无主编流程：不允许（主编不参与编辑阶段审核）
- 有主编流程：如果 `review_status = 'pending_chief'`，则允许终审，`chief_editor_admin_id = C`

**当前审核人：super_admin S**

**行为**：
- 无主编流程：`review_status = 'approved'`，`editor_admin_id = S`
- 有主编流程：如果 `review_status = 'pending_chief'`，则允许终审，`chief_editor_admin_id = novel.chief_editor_admin_id`

### 场景 B：chapter.editor_admin_id = E1，不同审核人再次审核

#### B1：同一个编辑 E1

**代码路径**：`chapterReviewService.js` 第 204-206 行

```javascript
if (chapter.editor_admin_id === adminId) {
  return { allowed: true };
}
```

**行为**：✅ 允许，`editor_admin_id` 保持不变（或重新设置为 E1）

#### B2：另一个编辑 E2

**代码路径**：`chapterReviewService.js` 第 221-232 行

```javascript
if (adminRole === 'editor' || adminRole === 'chief_editor') {
  if (existingRole === 'super_admin') {
    return { allowed: true };
  }
  
  // 否则（之前是其他编辑审批的），不允许覆盖
  return {
    allowed: false,
    reason: '该章节已由其他编辑审核通过，不能再次修改责任编辑'
  };
}
```

**行为**：❌ 不允许，抛出错误："该章节已由其他编辑审核通过，不能再次修改责任编辑"

#### B3：主编 C

**代码路径**：`permissionMiddleware.js` 第 214-217 行

```javascript
// 其它状态（submitted/reviewing/rejected...）只允许编辑和超管；
// 这里 super_admin 已经提前 return true，主编不参与第一阶段编辑审核
return adminRole === 'editor';
```

**行为**：❌ 不允许，`can_review = false`（主编不参与编辑阶段）

#### B4：super_admin S

**代码路径**：`chapterReviewService.js` 第 208-211 行

```javascript
if (adminRole === 'super_admin') {
  return { allowed: true };
}
```

**行为**：✅ 允许，`editor_admin_id` 覆盖为 S

### 场景 C：chapter.editor_admin_id = 超管 S 或主编 C1

#### C1：editor_admin_id = 超管 S，编辑 E 再次审核

**代码路径**：`chapterReviewService.js` 第 223-226 行

```javascript
if (existingRole === 'super_admin') {
  return { allowed: true };
}
```

**行为**：✅ 允许，`editor_admin_id` 覆盖为 E（编辑可从超管接盘）

#### C2：editor_admin_id = 主编 C1，其他人再次审核

**注意**：根据代码逻辑，`editor_admin_id` 通常不会设置为主编的 ID（主编终审时保持原值或使用 `novel.current_editor_admin_id`）。如果出现此情况：

- 编辑 E：如果 `existingRole = 'chief_editor'`，则不允许（第 228-232 行）
- 主编 C2：不允许（主编不参与编辑阶段）
- 超管 S：允许覆盖

### 场景 D：主编已经终审通过后，再次打开章节审核页

**问题描述**：主编已经终审通过（`review_status = 'approved'`，`chief_editor_admin_id = C`），主编再次打开同一章节审核页，接口是否仍返回"没有有效合同 / 没有权限审核"的错误？

#### 分析

**后端 can_review 计算**（`backend/routes/admin.js` 第 8857-8894 行）：

1. 首先调用 `computeChapterCanReview`：
   - `adminRole = 'chief_editor'`
   - 检查是否有有效主编合同 → ✅ 有（否则之前无法终审）
   - `requiresChiefEdit = true`（有主编流程）
   - `review_status = 'approved'`（不是 `pending_chief`）
   - 返回：`adminRole === 'editor'` → `false`（第 217 行）

2. 然后检查 `review_status !== 'pending_chief'`：
   - `'approved' !== 'pending_chief'` → `true`
   - 进入 `editor_admin_id` 覆盖规则检查（第 8866 行）

3. 检查 `editor_admin_id` 覆盖规则：
   - 如果 `chapter.editor_admin_id` 存在且不是当前主编，且不是超管，则 `can_review = false`

**结论**：

✅ **已修复**：根据最新代码（第 178-219 行的 `computeChapterCanReview`），`super_admin` 会提前返回 `true`，但 `chief_editor` 在 `review_status = 'approved'` 时，由于不是 `pending_chief`，会走到编辑阶段的判断，返回 `adminRole === 'editor'` → `false`。

**但是**，如果主编有有效合同，且 `review_status = 'approved'`，理论上主编应该可以查看（但不能再次审核，因为已经终审通过）。

**实际行为**：
- `can_review = false`（因为 `review_status = 'approved'` 不是 `pending_chief`，且主编不参与编辑阶段）
- 前端按钮全部禁用
- 显示提示："您当前在该小说上没有生效的编辑/主编合同，因此不能进行审核操作。"（如果 `currentAdminRole !== 'super_admin'`）

**问题根源**：
`computeChapterCanReview` 函数在 `review_status = 'approved'` 时，对于 `chief_editor` 返回 `false`，因为：
1. 有主编流程
2. `status !== 'pending_chief'`
3. 返回 `adminRole === 'editor'` → `false`

**修复建议**：
如果章节已经 `approved`，理论上任何人都不应该再次审核（除非是重新审核流程）。但如果需要允许主编查看已审核的章节，可以在 `computeChapterCanReview` 中添加对 `approved` 状态的特殊处理。

---

## 七、总结

### 7.1 核心规则总结

1. **super_admin 永远可以审核任意章节**（`computeChapterCanReview` 第 182-184 行）

2. **editor 必须有 active 编辑合同**，且：
   - 无主编流程：可以审核任意状态
   - 有主编流程：只能审核编辑阶段（`submitted/reviewing/rejected`），不能审核 `pending_chief`

3. **chief_editor 必须有 active 主编合同**，且：
   - 无主编流程：可以审核任意状态
   - 有主编流程：只能审核 `pending_chief` 状态，不能审核编辑阶段

4. **editor_admin_id 覆盖规则**（仅在编辑阶段生效）：
   - 空值 → 允许
   - 自己 → 允许
   - 超管 → 允许覆盖
   - 其他编辑 → 不允许（抢功防护）
   - 超管审过的 → 编辑可以接盘

5. **主编终审阶段**：
   - `editor_admin_id` 保持不变（如果已有值）
   - `chief_editor_admin_id` 设置为当前主编（如果为空）

### 7.2 已知问题

1. **主编已终审后无法查看**：当 `review_status = 'approved'` 时，`chief_editor` 的 `can_review` 返回 `false`，导致按钮禁用和提示显示。这可能不符合预期（如果只需要查看，不需要再次审核）。

2. **提示文案可能误导**：当 `can_review = false` 时，前端显示"没有生效的编辑/主编合同"，但实际上可能是其他原因（如状态限制、抢功防护等）。

---

## 八、代码引用索引

### 后端关键函数位置

| 函数名 | 文件 | 行号 |
|--------|------|------|
| `computeChapterCanReview` | `backend/middleware/permissionMiddleware.js` | 178-219 |
| `checkNovelPermission` | `backend/middleware/permissionMiddleware.js` | 57-110 |
| `canCurrentAdminOverrideEditor` | `backend/services/chapterReviewService.js` | 197-240 |
| `reviewChapter` | `backend/services/chapterReviewService.js` | 251-471 |
| `GET /api/admin/chapter/:id` | `backend/routes/admin.js` | 8722-9035 |

### 前端关键组件位置

| 组件/函数 | 文件 | 行号 |
|----------|------|------|
| `ChapterApproval` | `frontend/src/pages/AdminPanel/ChapterApproval/index.tsx` | 48-317 |
| `ChapterDetail` | `frontend/src/pages/AdminPanel/ChapterApproval/ChapterDetail.tsx` | 46-411 |
| `canApprove` | `frontend/src/pages/AdminPanel/ChapterApproval/ChapterDetail.tsx` | 110-128 |
| `getApproveButtonText` | `frontend/src/pages/AdminPanel/ChapterApproval/ChapterDetail.tsx` | 87-106 |

---

**报告结束**

