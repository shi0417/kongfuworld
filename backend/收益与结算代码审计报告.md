# 收益与结算代码审计报告

## 一、全局定位相关代码

### 1.1 后端文件定位

| 关键词 | 命中的文件 | 位置（行号区间） |
|--------|-----------|----------------|
| `reader_spending` | `backend/routes/admin.js` | 1665-2036, 2039-2180, 2320-2332, 2639-2650 |
| `author_royalty` | `backend/routes/admin.js` | 2288-2435, 1135-1156, 1142-1144, 2750-2761 |
| `commission_transaction` | `backend/routes/admin.js` | 2604-2895, 1159-1180, 1443-1466, 2480-2602 |
| `generate-reader-spending` | `backend/routes/admin.js` | 1665-2036 |
| `generate-author-royalty` | `backend/routes/admin.js` | 2288-2435 |
| `generate-commission` | `backend/routes/admin.js` | 2604-2895 |
| `结算总览` | `backend/routes/admin.js` | 4458-4596 |
| `读者收入统计` | `backend/routes/admin.js` | 1423-1623 |
| `作者收入统计` | `backend/routes/admin.js` | 1115-1412 |

### 1.2 前端文件定位

| 页面名称 | 前端文件路径 | 调用的API |
|---------|------------|----------|
| 基础收入统计 | `frontend/src/pages/AdminPanel/BaseIncome/index.tsx` | `GET /api/admin/reader-spending?month=...`<br>`POST /api/admin/generate-reader-spending` |
| 作者基础收入表 | `frontend/src/pages/AdminPanel/AuthorRoyalty/index.tsx` | `GET /api/admin/author-royalty?month=...`<br>`POST /api/admin/author-royalty/generate` |
| 推广佣金明细 | `frontend/src/pages/AdminPanel/CommissionTransaction/index.tsx` | `GET /api/admin/commission-transaction?month=...`<br>`POST /api/admin/commission-transaction/generate` |
| 结算总览 | `frontend/src/pages/AdminPanel.tsx` | `GET /api/admin/user-settlement/overview?month=...` |
| 读者收入统计 | `frontend/src/pages/AdminPanel/ReaderIncome/index.tsx` | `GET /api/admin/reader-income-stats?month=...` |
| 作者收入统计 | `frontend/src/pages/AdminPanel/AuthorIncome/index.tsx` | `GET /api/admin/author-income-stats?month=...` |

---

## 二、三张核心表的生成逻辑分析

### 2.1 reader_spending（基础收入统计）的生成过程

#### 2.1.1 入口 API / 按钮
- **前端页面**：`frontend/src/pages/AdminPanel/BaseIncome/index.tsx`
- **触发按钮**：「生成」按钮（`generateBaseIncomeData` 函数）
- **后端路由**：`POST /api/admin/generate-reader-spending`
- **文件位置**：`backend/routes/admin.js` 第 1665-2036 行

#### 2.1.2 后端入口函数
- **函数名**：`router.post('/generate-reader-spending', authenticateAdmin, async (req, res) => {...})`
- **是否使用事务**：❌ **未使用事务**
- **错误处理**：有 try-catch，但错误会被捕获并返回 500 状态码

#### 2.1.3 核心 SQL / 计算逻辑

**数据来源1：章节解锁（chapter_unlocks）**
```sql
SELECT 
  cu.id, cu.user_id, cu.chapter_id, cu.cost as karma_amount,
  cu.unlocked_at, c.novel_id
FROM chapter_unlocks cu
INNER JOIN chapter c ON cu.chapter_id = c.id
WHERE cu.unlocked_at >= ? 
  AND cu.unlocked_at < ?
  AND cu.unlock_method = 'karma'
  AND cu.cost > 0
ORDER BY cu.unlocked_at
```
- **月份过滤**：使用 `unlocked_at >= monthStart AND unlocked_at < monthEnd`（UTC 时间边界）
- **settlement_month**：设置为 `${month}-01`（例如：`2025-11-01`）
- **amount_usd 计算**：`karma_amount × usd_per_karma`（从 `karma_dollars` 表查询当时生效的汇率）

**数据来源2：Champion 订阅（user_champion_subscription_record）**
```sql
SELECT id, user_id, novel_id, payment_amount, start_date, end_date,
       subscription_duration_days, created_at
FROM user_champion_subscription_record
WHERE payment_status = 'completed'
  AND payment_amount > 0
  AND end_date > ?
  AND start_date < ?
ORDER BY start_date
```
- **月份过滤**：使用服务期与结算月份的交集判断（`end_date > monthStart AND start_date < monthEnd`）
- **settlement_month**：根据订阅服务期与月份的重叠情况，可能拆分到多个月份
- **amount_usd 计算**：按重叠天数比例拆分 `payment_amount`
  - 公式：`amountForMonth = payment_amount × (overlapDays / totalDays)`
  - 最后一个月使用"余额兜底"逻辑，确保总和严格等于 `payment_amount`

**插入 SQL**：
```sql
INSERT INTO reader_spending 
  (user_id, novel_id, karma_amount, amount_usd, source_type, source_id, spend_time, settlement_month, days)
VALUES (?, ?, ?, ?, 'subscription', ?, ?, ?, ?)
```

#### 2.1.4 month / settlement_month 的过滤条件
- **输入参数**：`month` 格式为 `2025-11`（YYYY-MM）
- **settlement_month 存储**：转换为 `2025-11-01`（DATE 类型）
- **月份边界计算**：使用 UTC 时间创建月份边界，避免时区问题
  ```javascript
  const [year, monthNum] = month.split('-').map(Number);
  const monthStartDate = new Date(Date.UTC(year, monthNum - 1, 1, 0, 0, 0, 0));
  const nextMonthDate = new Date(Date.UTC(year, monthNum, 1, 0, 0, 0, 0));
  ```

---

### 2.2 author_royalty（作者基础收入表）的生成过程

#### 2.2.1 入口 API / 按钮
- **前端页面**：`frontend/src/pages/AdminPanel/AuthorRoyalty/index.tsx`
- **触发按钮**：「生成」按钮（`generateAuthorRoyaltyData` 函数）
- **后端路由**：`POST /api/admin/author-royalty/generate`
- **文件位置**：`backend/routes/admin.js` 第 2288-2435 行

#### 2.2.2 后端入口函数
- **函数名**：`router.post('/author-royalty/generate', authenticateAdmin, async (req, res) => {...})`
- **是否使用事务**：❌ **未使用事务**
- **错误处理**：有 try-catch，但错误会被捕获并返回 500 状态码

#### 2.2.3 核心 SQL / 计算逻辑

**数据来源：reader_spending**
```sql
SELECT 
  rs.id, rs.user_id, rs.novel_id, rs.amount_usd, rs.spend_time
FROM reader_spending rs
WHERE rs.settlement_month = ?
ORDER BY rs.spend_time
```
- **月份过滤**：**仅使用 `settlement_month = ?`**（例如：`settlement_month = '2025-11-01'`）
- **⚠️ 关键发现**：**没有其他过滤条件**（例如：不检查 `settled` 状态、不检查 `source_type`）

**作者ID获取**：
```sql
SELECT user_id FROM novel WHERE id = ?
```
- **⚠️ 关键过滤**：如果 `novels.length === 0 || !novels[0].user_id`，**会跳过该条记录**（`continue`）
- **日志输出**：`console.warn(\`小说 ${spending.novel_id} 没有作者，跳过\`)`

**分成比例计算**：
1. 优先查找生效的合同（`novel_royalty_contract`）：
   ```sql
   SELECT plan_id 
   FROM novel_royalty_contract 
   WHERE novel_id = ? AND author_id = ?
     AND effective_from <= ? AND (effective_to IS NULL OR effective_to > ?)
   ORDER BY effective_from DESC LIMIT 1
   ```
2. 如果找到合同，从 `author_royalty_plan` 获取 `royalty_percent`
3. 如果没有合同，使用默认方案（`is_default = 1`）
4. **默认值**：如果没有默认方案，使用 `0.5`（50%）

**金额计算**：
- `gross_amount_usd = spending.amount_usd`（直接使用 reader_spending 的金额）
- `author_amount_usd = gross_amount_usd × royalty_percent`（使用高精度 Decimal）

**插入 SQL**：
```sql
INSERT INTO author_royalty 
  (author_id, novel_id, source_spend_id, gross_amount_usd, author_amount_usd, settlement_month)
VALUES (?, ?, ?, ?, ?, ?)
```

#### 2.2.4 month / settlement_month 的过滤条件
- **输入参数**：`month` 格式为 `2025-11`（YYYY-MM）
- **settlement_month 存储**：转换为 `2025-11-01`（DATE 类型）
- **查询条件**：**仅使用 `rs.settlement_month = ?`**，与 reader_spending 的存储格式一致

---

### 2.3 commission_transaction（推广佣金明细）的生成过程

#### 2.3.1 入口 API / 按钮
- **前端页面**：`frontend/src/pages/AdminPanel/CommissionTransaction/index.tsx`
- **触发按钮**：「生成」按钮
- **后端路由**：`POST /api/admin/commission-transaction/generate`
- **文件位置**：`backend/routes/admin.js` 第 2604-2895 行

#### 2.3.2 后端入口函数
- **函数名**：`router.post('/commission-transaction/generate', authenticateAdmin, async (req, res) => {...})`
- **是否使用事务**：❌ **未使用事务**
- **错误处理**：有 try-catch，但错误会被捕获并返回 500 状态码

#### 2.3.3 核心 SQL / 计算逻辑

**数据来源1：读者推广佣金（基于 reader_spending）**
```sql
SELECT rs.id, rs.user_id, rs.novel_id, rs.amount_usd, rs.spend_time
FROM reader_spending rs
WHERE rs.settlement_month = ?
ORDER BY rs.spend_time
```
- **月份过滤**：仅使用 `settlement_month = ?`
- **推广链查找**：沿 `referrals` 表向上查找多级上线（最多 10 层）
- **方案匹配**：使用 `referrals.promoter_plan_id`，如果方案过期则回退到默认方案
- **金额计算**：`commission_amount_usd = base_amount_usd × percent`（使用高精度 Decimal）

**数据来源2：作者推广佣金（基于 author_royalty）**
```sql
SELECT ar.id, ar.author_id, ar.novel_id, ar.author_amount_usd, ar.source_spend_id
FROM author_royalty ar
WHERE ar.settlement_month = ?
ORDER BY ar.created_at
```
- **月份过滤**：仅使用 `settlement_month = ?`
- **推广链查找**：沿 `referrals` 表向上查找多级上线（最多 10 层）
- **方案匹配**：使用 `referrals.author_plan_id`，如果方案过期则回退到默认方案
- **金额计算**：`commission_amount_usd = base_amount_usd × percent`（`base_amount_usd` 来自 `author_royalty.author_amount_usd`）

**插入 SQL**：
```sql
INSERT INTO commission_transaction 
  (user_id, source_user_id, novel_id, plan_id, level, commission_type,
   base_amount_usd, commission_amount_usd, reference_id, settlement_month)
VALUES (?, ?, ?, ?, ?, 'reader_referral', ?, ?, ?, ?)
```

#### 2.3.4 month / settlement_month 的过滤条件
- **输入参数**：`month` 格式为 `2025-11`（YYYY-MM）
- **settlement_month 存储**：转换为 `2025-11-01`（DATE 类型）
- **查询条件**：与 reader_spending 和 author_royalty 的存储格式一致

---

## 三、结算总览 & 读者/作者收入统计

### 3.1 结算总览

**前端页面**：`frontend/src/pages/AdminPanel.tsx`（推测，未找到明确文件）

**后端 API**：`GET /api/admin/user-settlement/overview`
- **文件位置**：`backend/routes/admin.js` 第 4458-4596 行

**数据来源**：
- **直接读取表**：`user_income_monthly`（用户月度收入汇总表）
- **关联表**：
  - `user`（用户信息）
  - `user_payout`（支付记录）
- **金额字段**：
  - `month_author_base_income`：来自 `user_income_monthly.author_base_income_usd`
  - `month_reader_referral_income`：来自 `user_income_monthly.reader_referral_income_usd`
  - `month_author_referral_income`：来自 `user_income_monthly.author_referral_income_usd`
  - `month_total_income`：来自 `user_income_monthly.total_income_usd`

**⚠️ 注意**：结算总览**不是实时统计**，而是从 `user_income_monthly` 表读取已汇总的数据。该表的数据需要通过其他接口（如 `/api/admin/user-settlement/calculate`）计算并写入。

### 3.2 读者收入统计

**前端页面**：`frontend/src/pages/AdminPanel/ReaderIncome/index.tsx`

**后端 API**：`GET /api/admin/reader-income-stats`
- **文件位置**：`backend/routes/admin.js` 第 1423-1623 行

**数据来源**：
- **直接读取表**：`commission_transaction`（`commission_type = 'reader_referral'`）
- **关联表**：
  - `user`（推广人信息）
  - `reader_spending`（用于展示消费明细）
- **月份过滤**：`ct.settlement_month = ?`（格式：`2025-11-01`）

**金额字段**：
- `total_referral_income_usd`：`SUM(ct.commission_amount_usd)`（按推广人分组）

### 3.3 作者收入统计

**前端页面**：`frontend/src/pages/AdminPanel/AuthorIncome/index.tsx`

**后端 API**：`GET /api/admin/author-income-stats`
- **文件位置**：`backend/routes/admin.js` 第 1115-1412 行

**数据来源**：
- **基础收入**：`author_royalty` 表（`WHERE ar.settlement_month = ?`）
- **推广收入**：`commission_transaction` 表（`commission_type = 'author_referral' AND ct.settlement_month = ?`）
- **关联表**：
  - `user`（作者信息）
  - `novel`（小说信息）
  - `reader_spending`（用于展示消费明细）

**金额字段**：
- `base_income_usd`：`SUM(ar.author_amount_usd)`（按作者分组）
- `referral_income_usd`：`SUM(ct.commission_amount_usd)`（按作者分组）

---

## 四、重点问题分析

### 4.1 问题1：基础收入统计页面能看到 2025-11 的订阅收入，但作者基础收入表是空的

#### 4.1.1 reader_spending 记录的写入过程

**示例：一条订阅来源的 reader_spending 记录**

假设有一条 `user_champion_subscription_record` 记录：
- `id = 1`
- `user_id = 1`
- `novel_id = 7`
- `payment_amount = 3.00`
- `start_date = 2025-11-02 22:03:15`
- `end_date = 2025-12-02 22:03:15`
- `subscription_duration_days = 30`

**生成 2025-11 月份数据时的处理流程**：

1. **月份边界计算**：
   ```javascript
   monthStartDate = 2025-11-01 00:00:00 UTC
   nextMonthDate = 2025-12-01 00:00:00 UTC
   settlementMonth = '2025-11-01'
   ```

2. **订阅筛选**：
   ```sql
   WHERE payment_status = 'completed'
     AND payment_amount > 0
     AND end_date > '2025-11-01 00:00:00'
     AND start_date < '2025-12-01 00:00:00'
   ```
   ✅ 该订阅会被选中（服务期与 2025-11 有交集）

3. **重叠天数计算**：
   ```javascript
   serviceStart = normalizeToUTCDate('2025-11-02 22:03:15') = 2025-11-02 00:00:00 UTC
   serviceEnd = normalizeToUTCDate('2025-12-02 22:03:15') = 2025-12-02 00:00:00 UTC
   overlapStart = max(serviceStart, monthStartDate) = 2025-11-02 00:00:00 UTC
   overlapEnd = min(serviceEnd, nextMonthDate) = 2025-11-30 23:59:59 UTC（实际是 2025-12-01 00:00:00 UTC，半开区间）
   overlapDays = diffDays(overlapStart, overlapEnd) = 29 天（11月2日~11月30日）
   ```

4. **金额拆分**：
   ```javascript
   totalDays = diffDays(serviceStart, serviceEnd) = 30 天
   ratio = overlapDays / totalDays = 29 / 30
   amountForMonth = payment_amount × ratio = 3.00 × (29/30) = 2.90
   ```

5. **插入 reader_spending**：
   ```sql
   INSERT INTO reader_spending 
     (user_id, novel_id, karma_amount, amount_usd, source_type, source_id, spend_time, settlement_month, days)
   VALUES (1, 7, 0, 2.90, 'subscription', 1, '2025-11-02 00:00:00', '2025-11-01', 29)
   ```

**数据库中的字段值**：
- `settlement_month`：`2025-11-01`（DATE 类型）
- `spend_time`：`2025-11-02 00:00:00`（DATETIME 类型）
- `amount_usd`：`2.90`（DECIMAL(20,8)）
- `source_type`：`'subscription'`
- `source_id`：`1`（对应 `user_champion_subscription_record.id`）

#### 4.1.2 author_royalty 的生成过程

**当在「作者基础收入表」页面选择 2025-11 并点击「生成」时**：

1. **查询 reader_spending**：
   ```sql
   SELECT rs.id, rs.user_id, rs.novel_id, rs.amount_usd, rs.spend_time
   FROM reader_spending rs
   WHERE rs.settlement_month = '2025-11-01'
   ORDER BY rs.spend_time
   ```
   ✅ 应该能找到上面插入的记录

2. **获取小说的作者ID**：
   ```sql
   SELECT user_id FROM novel WHERE id = 7
   ```
   ⚠️ **关键问题点**：如果 `novel.id = 7` 不存在，或者 `novel.user_id` 为 `NULL`，**会跳过该条记录**：
   ```javascript
   if (novels.length === 0 || !novels[0].user_id) {
     console.warn(`小说 ${spending.novel_id} 没有作者，跳过`);
     continue; // ⚠️ 跳过，不会生成 author_royalty
   }
   ```

3. **查找分成合同**：
   ```sql
   SELECT plan_id 
   FROM novel_royalty_contract 
   WHERE novel_id = 7 AND author_id = ?
     AND effective_from <= '2025-11-02 00:00:00'
     AND (effective_to IS NULL OR effective_to > '2025-11-02 00:00:00')
   ORDER BY effective_from DESC LIMIT 1
   ```
   - 如果找到合同，使用合同中的 `plan_id` 对应的 `royalty_percent`
   - 如果没有合同，使用默认方案（`is_default = 1`）
   - 如果连默认方案都没有，使用 `0.5`（50%）

4. **计算并插入 author_royalty**：
   ```sql
   INSERT INTO author_royalty 
     (author_id, novel_id, source_spend_id, gross_amount_usd, author_amount_usd, settlement_month)
   VALUES (?, 7, ?, 2.90, ?, '2025-11-01')
   ```

#### 4.1.3 为什么 author_royalty 是空的？

**可能的原因（按可能性排序）**：

1. **❌ 小说没有作者（最可能）**
   - `novel.id = 7` 不存在，或者 `novel.user_id` 为 `NULL`
   - **验证方法**：
     ```sql
     SELECT id, user_id, title FROM novel WHERE id = 7;
     ```
   - **修复方法**：确保 `novel` 表中有对应的记录，且 `user_id` 不为 `NULL`

2. **✅ settlement_month 匹配正确**
   - `reader_spending.settlement_month = '2025-11-01'`
   - `author_royalty` 生成时查询条件也是 `rs.settlement_month = '2025-11-01'`
   - **结论**：月份匹配没有问题

3. **✅ source_type 没有被排除**
   - `author_royalty` 生成逻辑**没有过滤 `source_type`**
   - 无论是 `'chapter_unlock'` 还是 `'subscription'`，都会被处理
   - **结论**：source_type 不是问题

4. **⚠️ 其他过滤条件**
   - `author_royalty` 生成逻辑**没有其他过滤条件**（例如：不检查 `settled` 状态）
   - **结论**：没有其他过滤条件导致问题

**最可能的原因**：**`novel` 表中对应的记录不存在，或者 `novel.user_id` 为 `NULL`**

---

### 4.2 问题2：推广佣金明细的兼容性

#### 4.2.1 读者推广佣金

**数据来源**：`reader_spending`（`settlement_month = ?`）
- ✅ **已兼容新的 subscription 拆分体系**
- 查询条件：`WHERE rs.settlement_month = ?`，与 reader_spending 的存储格式一致
- 不区分 `source_type`，无论是 `'chapter_unlock'` 还是 `'subscription'` 都会被处理

#### 4.2.2 作者推广佣金

**数据来源**：`author_royalty`（`settlement_month = ?`）
- ✅ **已兼容新的 subscription 拆分体系**
- 前提条件：必须先成功生成 `author_royalty`
- 如果 `author_royalty` 为空（例如：小说没有作者），则作者推广佣金也会为空

**结论**：推广佣金明细的生成逻辑**已经兼容新的 subscription 拆分体系**，但依赖于 `author_royalty` 的正确生成。

---

## 五、数据关系图

```
┌─────────────────────────────────────────────────────────────┐
│                   数据生成流程（按顺序）                      │
└─────────────────────────────────────────────────────────────┘

1. reader_spending（基础收入统计）
   ├─ 来源1：chapter_unlocks（章节解锁）
   │   └─ 筛选：unlocked_at 在月份范围内 + unlock_method='karma' + cost>0
   │   └─ 计算：amount_usd = karma_amount × usd_per_karma
   │   └─ 存储：settlement_month = '2025-11-01'
   │
   └─ 来源2：user_champion_subscription_record（订阅）
       └─ 筛选：服务期与月份有交集 + payment_status='completed' + payment_amount>0
       └─ 计算：amount_usd = payment_amount × (overlapDays / totalDays)
       └─ 存储：settlement_month = '2025-11-01'（可能拆分到多个月份）

2. author_royalty（作者基础收入表）
   └─ 来源：reader_spending
       └─ 筛选：settlement_month = '2025-11-01'
       └─ 关联：novel.user_id（作者ID）
       └─ ⚠️ 如果 novel.user_id 为 NULL，跳过
       └─ 计算：author_amount_usd = amount_usd × royalty_percent
       └─ 存储：settlement_month = '2025-11-01'

3. commission_transaction（推广佣金明细）
   ├─ 来源1：reader_spending（读者推广）
   │   └─ 筛选：settlement_month = '2025-11-01'
   │   └─ 推广链：沿 referrals 表向上查找多级上线
   │   └─ 计算：commission_amount_usd = base_amount_usd × percent
   │
   └─ 来源2：author_royalty（作者推广）
       └─ 筛选：settlement_month = '2025-11-01'
       └─ 推广链：沿 referrals 表向上查找多级上线
       └─ 计算：commission_amount_usd = base_amount_usd × percent

4. user_income_monthly（用户月度收入汇总）
   └─ 来源：author_royalty + commission_transaction
       └─ 汇总：按 user_id + month 分组
       └─ 字段：author_base_income_usd, reader_referral_income_usd, author_referral_income_usd

5. 结算总览 / 读者收入统计 / 作者收入统计
   └─ 数据来源：直接读取上述表（不是实时统计）
```

---

## 六、发现的潜在问题列表

### 问题1：author_royalty 生成时缺少作者ID检查的明确提示
- **位置**：`backend/routes/admin.js` 第 2351-2354 行
- **问题**：当 `novel.user_id` 为 `NULL` 时，只输出 `console.warn`，前端用户看不到明确的错误提示
- **影响**：用户点击「生成」后，如果所有记录都因为缺少作者ID而被跳过，前端只会显示"生成成功，0 条记录"，用户不知道为什么是空的
- **建议**：在返回结果中明确列出被跳过的记录及原因

### 问题2：未使用事务，可能导致部分数据生成失败
- **位置**：`backend/routes/admin.js` 第 1665-2036 行（generate-reader-spending）、第 2288-2435 行（generate-author-royalty）、第 2604-2895 行（generate-commission-transaction）
- **问题**：三个生成接口都未使用数据库事务，如果中途出错，可能导致部分数据已写入，部分未写入，数据不一致
- **影响**：数据完整性风险
- **建议**：使用事务包装整个生成过程，确保原子性

### 问题3：author_royalty 生成时没有检查小说状态
- **位置**：`backend/routes/admin.js` 第 2344-2414 行
- **问题**：即使小说状态为"已下架"或"未审核通过"，只要 `novel.user_id` 存在，就会生成 `author_royalty`
- **影响**：可能给已下架小说的作者分配收入
- **建议**：添加小说状态过滤条件（例如：只处理 `status = 'approved'` 的小说）

### 问题4：settlement_month 格式不一致的风险
- **位置**：多处
- **问题**：虽然代码中统一使用 `'2025-11-01'` 格式，但如果未来有其他地方直接使用 `'2025-11'` 字符串比较，可能导致查询失败
- **影响**：潜在的查询失败风险
- **建议**：统一使用 DATE 类型比较，或添加格式验证

### 问题5：commission_transaction 生成依赖 author_royalty，但错误提示不明确
- **位置**：`backend/routes/admin.js` 第 2750-2761 行
- **问题**：如果 `author_royalty` 为空（例如：所有小说都没有作者），`commission_transaction` 的"作者推广佣金"部分也会为空，但前端用户可能不知道为什么
- **影响**：用户体验不佳
- **建议**：在返回结果中明确说明"作者推广佣金为 0 的原因"（例如：没有 author_royalty 数据）

### 问题6：缺少数据完整性校验
- **位置**：所有生成接口
- **问题**：生成完成后，没有校验数据完整性（例如：`author_royalty` 的总金额是否等于 `reader_spending` 的总金额 × 分成比例）
- **影响**：可能生成错误的数据而不自知
- **建议**：在生成完成后添加数据完整性校验，输出警告或错误

---

## 七、针对"作者基础收入表为空"问题的诊断步骤

### 步骤1：检查 reader_spending 数据是否存在
```sql
SELECT id, user_id, novel_id, amount_usd, source_type, settlement_month
FROM reader_spending
WHERE settlement_month = '2025-11-01';
```
- **预期结果**：应该能看到订阅相关的记录
- **如果为空**：说明 `generate-reader-spending` 没有成功生成数据

### 步骤2：检查 novel 表是否有对应的记录和作者ID
```sql
SELECT id, user_id, title, status
FROM novel
WHERE id IN (
  SELECT DISTINCT novel_id FROM reader_spending WHERE settlement_month = '2025-11-01'
);
```
- **预期结果**：所有 `novel_id` 都应该有对应的记录，且 `user_id` 不为 `NULL`
- **如果 `user_id` 为 `NULL`**：这就是问题所在

### 步骤3：检查 author_royalty 生成日志
- **查看后端服务器日志**：查找 `console.warn(\`小说 ${spending.novel_id} 没有作者，跳过\`)` 的输出
- **如果看到该警告**：说明确实是因为 `novel.user_id` 为 `NULL` 导致跳过

### 步骤4：检查分成合同是否存在
```sql
SELECT nrc.*, arp.royalty_percent
FROM novel_royalty_contract nrc
LEFT JOIN author_royalty_plan arp ON nrc.plan_id = arp.id
WHERE nrc.novel_id IN (
  SELECT DISTINCT novel_id FROM reader_spending WHERE settlement_month = '2025-11-01'
)
AND nrc.effective_from <= '2025-11-30 23:59:59'
AND (nrc.effective_to IS NULL OR nrc.effective_to > '2025-11-01 00:00:00');
```
- **预期结果**：应该有对应的合同，或者有默认方案（`is_default = 1`）
- **如果没有合同也没有默认方案**：会使用 50% 的默认值，但不会导致记录为空

---

## 八、总结

### 8.1 数据生成流程总结

1. **reader_spending**：从 `chapter_unlocks` 和 `user_champion_subscription_record` 生成，按月份拆分订阅
2. **author_royalty**：从 `reader_spending` 生成，需要 `novel.user_id` 存在
3. **commission_transaction**：从 `reader_spending` 和 `author_royalty` 生成，依赖推广链和方案配置

### 8.2 为什么"作者基础收入表为空"？

**最可能的原因**：**`novel` 表中对应的记录不存在，或者 `novel.user_id` 为 `NULL`**

**验证方法**：
```sql
SELECT n.id, n.user_id, n.title, COUNT(rs.id) as reader_spending_count
FROM novel n
LEFT JOIN reader_spending rs ON n.id = rs.novel_id AND rs.settlement_month = '2025-11-01'
WHERE rs.id IS NOT NULL
GROUP BY n.id, n.user_id, n.title;
```

如果 `user_id` 为 `NULL`，则说明问题确实在这里。

### 8.3 修复建议（优先级排序）

1. **高优先级**：修复 `novel.user_id` 为 `NULL` 的问题（如果确实存在）
2. **中优先级**：在 `author_royalty` 生成接口中添加更明确的错误提示，列出被跳过的记录
3. **中优先级**：使用事务包装生成过程，确保数据一致性
4. **低优先级**：添加数据完整性校验
5. **低优先级**：添加小说状态过滤条件

---

**报告生成时间**：2025-11-29
**审计范围**：收益与结算相关代码（6个后台页面/功能）
**审计方法**：代码静态分析 + SQL 逻辑梳理

