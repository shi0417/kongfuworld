# 章节收费 & 解锁价 & is_advance 预读功能现状分析报告

**生成时间**：2025-12-06  
**分析目标**：全面梳理章节收费、解锁价、is_advance 预读功能的现有代码逻辑，并与目标业务逻辑进行对比

---

## 一、代码实际逻辑汇总

### 1.1 章节创建/更新时 key_cost、unlock_price、is_advance 的设置逻辑

#### 1.1.1 创建章节接口（`POST /api/chapter/create`）

**文件位置**：`backend/routes/novelCreation.js` (第 1126-1462 行)

**完整流程**：

1. **判断章节号范围**（第 1191-1199 行）：
   ```javascript
   if (chapterNumber <= 50) {
     // 前50章节：免费章节
     isAdvance = 0;
     keyCost = 0;
     unlockPrice = 0;
   } else {
     // 第50章节之后：收费章节
     keyCost = 1;
     // 继续处理 is_advance 和 unlock_price
   }
   ```
   **⚠️ 关键发现**：硬编码了 `chapterNumber <= 50`，而不是使用 `unlockprice.default_free_chapters`

2. **处理 is_advance 逻辑**（第 1203-1306 行）：
   - **步骤 1**：查询小说的 `champion_status`
     ```sql
     SELECT champion_status FROM novel WHERE id = ?
     ```
   - **步骤 2**：如果 `champion_status != 'approved'`
     ```javascript
     isAdvance = 0;
     ```
   - **步骤 3**：如果 `champion_status === 'approved'`
     - 查询最大 `tier_level` 的 `advance_chapters` 值（设为 A）
       ```sql
       SELECT advance_chapters
       FROM novel_champion_tiers
       WHERE novel_id = ? AND is_active = 1
         AND tier_level = (
           SELECT MAX(tier_level)
           FROM novel_champion_tiers
           WHERE novel_id = ? AND is_active = 1
         )
       LIMIT 1
       ```
     - 查询该小说 `chapter` 表中 `is_advance=1` 的数据条数（设为 B）
       ```sql
       SELECT COUNT(*) as count
       FROM chapter
       WHERE novel_id = ? AND is_advance = 1
       ```
     - 比较 A 和 B：
       - **如果 A > B**：`isAdvance = 1`
       - **如果 A = B**：
         - `isAdvance = 1`
         - 查找倒数第 `A+1` 条 `is_advance=1` 的数据，将其 `is_advance` 改为 0
         ```sql
         SELECT id
         FROM chapter
         WHERE novel_id = ? AND is_advance = 1
         ORDER BY chapter_number DESC
         LIMIT 1 OFFSET ?
         -- OFFSET 值为 maxAdvanceChapters（即 A）
         ```
       - **如果 A < B**：`isAdvance = 0`（理论上不应该发生）

3. **处理 unlock_price 逻辑**（第 1308-1368 行）：
   - **步骤 1**：获取小说的 `user_id`
     ```sql
     SELECT user_id FROM novel WHERE id = ?
     ```
   - **步骤 2**：查询 `unlockprice` 表
     ```sql
     SELECT karma_per_1000, min_karma, max_karma, default_free_chapters
     FROM unlockprice
     WHERE novel_id = ? AND user_id = ?
     LIMIT 1
     ```
   - **步骤 3**：根据查询结果计算 `unlock_price`
     - **如果没有数据**：
       1. 创建一条默认记录：
         ```sql
         INSERT INTO unlockprice (user_id, novel_id, karma_per_1000, min_karma, max_karma, default_free_chapters, pricing_style)
         VALUES (?, ?, 6, 5, 30, 50, 'per_word')
         ON DUPLICATE KEY UPDATE updated_at = NOW()
         ```
       2. 使用默认配置计算价格：
         ```javascript
         const config = { karma_per_1000: 6, min_karma: 5, max_karma: 30, default_free_chapters: 50 };
         unlockPrice = calculateChapterPrice(chapterNumber, wordCount || 0, config);
         ```
     - **如果有数据**：
       ```javascript
       const config = unlockPriceResults[0];
       unlockPrice = calculateChapterPrice(chapterNumber, wordCount || 0, config);
       ```

4. **calculateChapterPrice 函数**（第 49-70 行）：
   ```javascript
   function calculateChapterPrice(chapterNumber, wordCount, config) {
     const { karma_per_1000, min_karma, max_karma, default_free_chapters } = config;
     
     // 1. 前N章免费
     if (chapterNumber <= default_free_chapters) {
       return 0;
     }
     
     // 2. 没字数时默认用min_karma
     if (!wordCount || wordCount <= 0) {
       return min_karma;
     }
     
     // 3. 按字数计算基础价：向上取整
     let basePrice = Math.ceil((wordCount / 1000) * karma_per_1000);
     
     // 4. 限制在 [min_karma, max_karma] 区间
     if (basePrice < min_karma) basePrice = min_karma;
     if (basePrice > max_karma) basePrice = max_karma;
     
     return basePrice;
   }
   ```

#### 1.1.2 更新章节接口（`POST /api/chapter/update`）

**文件位置**：`backend/routes/novelCreation.js` (第 1465-1807 行)

**关键逻辑**：

1. **unlock_price 更新**（第 1587-1672 行）：
   - **触发条件**：只有当 `action === 'publish' || action === 'schedule'` 时才计算 `unlock_price`
   - **⚠️ 关键发现**：
     - 保存草稿时（`action === 'draft'`）**不会更新 `unlock_price`**
     - 只有在发布操作时才会重新计算
   - **计算逻辑**：与创建章节相同，使用 `calculateChapterPrice` 函数
   - **⚠️ 差异点**：更新章节时，会先判断 `currentChapterNumber > config.default_free_chapters`，如果小于等于，直接设置 `unlockPrice = 0`

2. **is_advance 和 key_cost 更新**：
   - **⚠️ 关键发现**：更新章节时，**不会重新计算 `is_advance` 和 `key_cost`**
   - 这两个字段只在创建章节时设置，更新时不会改变

---

### 1.2 unlockprice 表在当前代码中的用途

#### 1.2.1 表结构

**当前使用的字段**：
- `user_id`：作者ID
- `novel_id`：小说ID
- `karma_per_1000`：每1000字的karma价格
- `min_karma`：最小karma价格
- `max_karma`：最大karma价格
- `default_free_chapters`：默认免费章节数
- `pricing_style`：计价模式（目前只使用 `'per_word'`）

**已废弃的字段**（在迁移脚本中发现）：
- `fixed_style`：费用模式（0=随机，1=固定）
- `fixed_cost`：固定费用值
- `random_cost_min`：随机费用最小值
- `random_cost_max`：随机费用最大值

**迁移脚本位置**：`backend/migrations/add_pricing_system_fields.sql` (第 59-65 行)

#### 1.2.2 读写位置汇总

**读取位置**：

1. **创建章节时**（`backend/routes/novelCreation.js` 第 1330-1340 行）：
   ```sql
   SELECT karma_per_1000, min_karma, max_karma, default_free_chapters
   FROM unlockprice
   WHERE novel_id = ? AND user_id = ?
   LIMIT 1
   ```

2. **更新章节时**（`backend/routes/novelCreation.js` 第 1617-1627 行）：
   - 同样的查询逻辑

3. **批量更新章节价格**（`backend/routes/novelCreation.js` 第 2012-2017 行）：
   ```sql
   SELECT karma_per_1000, min_karma, max_karma, default_free_chapters
   FROM unlockprice
   WHERE novel_id = ? AND user_id = ?
   LIMIT 1
   ```

4. **后台管理**（`backend/routes/admin.js` 第 9369 行）：
   ```sql
   SELECT * FROM unlockprice WHERE novel_id = ? LIMIT 1
   ```

**写入位置**：

1. **创建章节时自动创建**（`backend/routes/novelCreation.js` 第 1346-1350 行）：
   ```sql
   INSERT INTO unlockprice (user_id, novel_id, karma_per_1000, min_karma, max_karma, default_free_chapters, pricing_style)
   VALUES (?, ?, 6, 5, 30, 50, 'per_word')
   ON DUPLICATE KEY UPDATE updated_at = NOW()
   ```

2. **更新章节时自动创建**（`backend/routes/novelCreation.js` 第 1634-1638 行）：
   - 同样的逻辑

3. **创建小说时**（`backend/routes/novelCreation.js` 第 356-363 行）：
   ```sql
   INSERT INTO unlockprice 
   (user_id, novel_id, karma_per_1000, min_karma, max_karma, default_free_chapters, pricing_style, created_at, updated_at)
   VALUES (?, ?, 6, 5, 30, 50, 'per_word', NOW(), NOW())
   ```

4. **后台管理更新**（`backend/routes/admin.js` 第 9397-9444 行）：
   - `PUT /api/admin/novels/:novelId/unlockprice` 接口
   - 支持更新 `karma_per_1000`, `min_karma`, `max_karma`, `default_free_chapters`

#### 1.2.3 当前 unlock_price 计算方式

**计算公式**（`calculateChapterPrice` 函数）：
```javascript
// 1. 如果 chapter_number <= default_free_chapters，返回 0
// 2. 如果 wordCount <= 0，返回 min_karma
// 3. 否则：
basePrice = Math.ceil((wordCount / 1000) * karma_per_1000)
unlock_price = clamp(basePrice, min_karma, max_karma)
```

**与目标逻辑的对比**：
- ✅ **已实现**：按字数计价（`pricing_style = 'per_word'`）
- ✅ **已实现**：使用 `default_free_chapters` 判断免费章节
- ✅ **已实现**：使用 `clamp` 函数限制价格区间
- ⚠️ **部分实现**：创建章节时硬编码了 `chapterNumber <= 50`，而不是使用 `unlockprice.default_free_chapters`

---

### 1.3 is_advance 与 novel_champion_tiers / champion_status 的当前关系

#### 1.3.1 当前实现逻辑

**文件位置**：`backend/routes/novelCreation.js` (第 1203-1306 行)

**完整流程**：

1. **检查 champion_status**：
   ```sql
   SELECT champion_status FROM novel WHERE id = ?
   ```
   - 如果 `champion_status != 'approved'`：`isAdvance = 0`
   - 如果 `champion_status === 'approved'`：继续处理

2. **查询最大 tier_level 的 advance_chapters**（设为 A）：
   ```sql
   SELECT advance_chapters
   FROM novel_champion_tiers
   WHERE novel_id = ? AND is_active = 1
     AND tier_level = (
       SELECT MAX(tier_level)
       FROM novel_champion_tiers
       WHERE novel_id = ? AND is_active = 1
     )
   LIMIT 1
   ```

3. **查询当前 is_advance=1 的数量**（设为 B）：
   ```sql
   SELECT COUNT(*) as count
   FROM chapter
   WHERE novel_id = ? AND is_advance = 1
   ```

4. **比较 A 和 B**：
   - **如果 A > B**：`isAdvance = 1`
   - **如果 A = B**：
     - `isAdvance = 1`
     - 查找倒数第 `A+1` 条 `is_advance=1` 的数据，将其 `is_advance` 改为 0
     ```sql
     SELECT id
     FROM chapter
     WHERE novel_id = ? AND is_advance = 1
     ORDER BY chapter_number DESC
     LIMIT 1 OFFSET ?
     ```
   - **如果 A < B**：`isAdvance = 0`（理论上不应该发生）

#### 1.3.2 与目标逻辑的对比

**目标逻辑**：
- 只在 `novel.champion_status = 'approved'` 时生效 ✅ **已实现**
- 在 `novel_champion_tiers` 中找到最大 `tier_level` 对应的 `advance_chapters`，记为 A ✅ **已实现**
- 在 `chapter` 表中统计 `is_advance = 1` 的数量，记为 B ✅ **已实现**
- 如果 A > B：新创建的章节 `is_advance = 1` ✅ **已实现**
- 如果 A = B：新创建的章节 `is_advance = 1`，同时将倒数第 `A+1` 条的 `is_advance` 改为 0 ✅ **已实现**
- 如果 `champion_status != 'approved'`：`is_advance` 永远为 0 ✅ **已实现**

**⚠️ 关键发现**：
- ✅ **已完全实现**：`is_advance` 的滑动窗口逻辑与目标逻辑完全一致
- ⚠️ **问题**：更新章节时不会重新计算 `is_advance`，可能导致数据不一致

---

## 二、与目标逻辑的差异点

### 2.1 免费 vs 收费章节逻辑

#### 2.1.1 目标逻辑

- 如果 `chapter_number <= up.default_free_chapters`：
  - `is_advance = 0`
  - `key_cost = 0`
  - `unlock_price = 0`
- 如果 `chapter_number > up.default_free_chapters`：
  - `key_cost = 1`
  - `unlock_price` 根据字数和 `up` 中参数计算

#### 2.1.2 当前实现

**创建章节时**（第 1194-1201 行）：
```javascript
if (chapterNumber <= 50) {
  // 前50章节：免费章节
  isAdvance = 0;
  keyCost = 0;
  unlockPrice = 0;
} else {
  // 第50章节之后：收费章节
  keyCost = 1;
  // 继续处理 is_advance 和 unlock_price
}
```

**差异点**：
- ❌ **硬编码了 `50`**，而不是使用 `unlockprice.default_free_chapters`
- ✅ **后续的 `unlock_price` 计算**使用了 `default_free_chapters`（在 `calculateChapterPrice` 函数中）

**更新章节时**（第 1654-1659 行）：
```javascript
if (currentChapterNumber > config.default_free_chapters) {
  unlockPrice = calculateChapterPrice(currentChapterNumber, parseInt(calculatedWordCount) || 0, config);
} else {
  unlockPrice = 0; // 免费章节
}
```

**差异点**：
- ✅ **使用了 `config.default_free_chapters`**，与目标逻辑一致
- ⚠️ **但只在发布操作时更新**，保存草稿时不会更新

---

### 2.2 按字数计价公式

#### 2.2.1 目标逻辑

```
base_price = ceil(word_count / 1000) * up.karma_per_1000
unlock_price = clamp(base_price, up.min_karma, up.max_karma)
```

#### 2.2.2 当前实现

**calculateChapterPrice 函数**（第 49-70 行）：
```javascript
function calculateChapterPrice(chapterNumber, wordCount, config) {
  const { karma_per_1000, min_karma, max_karma, default_free_chapters } = config;
  
  // 1. 前N章免费
  if (chapterNumber <= default_free_chapters) {
    return 0;
  }
  
  // 2. 没字数时默认用min_karma
  if (!wordCount || wordCount <= 0) {
    return min_karma;
  }
  
  // 3. 按字数计算基础价：向上取整
  let basePrice = Math.ceil((wordCount / 1000) * karma_per_1000);
  
  // 4. 限制在 [min_karma, max_karma] 区间
  if (basePrice < min_karma) basePrice = min_karma;
  if (basePrice > max_karma) basePrice = max_karma;
  
  return basePrice;
}
```

**对比结果**：
- ✅ **完全一致**：计算公式与目标逻辑完全一致
- ✅ **额外处理**：当 `wordCount <= 0` 时，返回 `min_karma`（目标逻辑未明确说明，但这是合理的默认值）

---

### 2.3 default_free_chapters 用法

#### 2.3.1 目标逻辑

- 使用 `up.default_free_chapters` 判断免费章节
- 每本书都可以不一样（通过 `unlockprice` 表配置）

#### 2.3.2 当前实现

**创建章节时**：
- ❌ **硬编码了 `50`**（第 1194 行）
- ✅ **但 `unlock_price` 计算时使用了 `default_free_chapters`**（在 `calculateChapterPrice` 函数中）

**更新章节时**：
- ✅ **使用了 `config.default_free_chapters`**（第 1655 行）

**问题**：
- ⚠️ **不一致**：创建章节时，`key_cost` 和 `is_advance` 的判断使用了硬编码的 `50`，而 `unlock_price` 使用了 `default_free_chapters`
- ⚠️ **可能导致**：如果某本书的 `default_free_chapters = 30`，前 30 章的 `unlock_price = 0`，但 `key_cost` 和 `is_advance` 仍然按照 `chapter_number <= 50` 的逻辑处理

---

### 2.4 is_advance 滑动窗口逻辑

#### 2.4.1 目标逻辑

- 只在 `novel.champion_status = 'approved'` 时生效 ✅
- 在 `novel_champion_tiers` 中找到最大 `tier_level` 对应的 `advance_chapters`，记为 A ✅
- 在 `chapter` 表中统计 `is_advance = 1` 的数量，记为 B ✅
- 如果 A > B：新创建的章节 `is_advance = 1` ✅
- 如果 A = B：新创建的章节 `is_advance = 1`，同时将倒数第 `A+1` 条的 `is_advance` 改为 0 ✅
- 如果 `champion_status != 'approved'`：`is_advance` 永远为 0 ✅

#### 2.4.2 当前实现

**完全一致** ✅

**⚠️ 但有一个问题**：
- 更新章节时不会重新计算 `is_advance`
- 如果用户修改了章节号，或者 `champion_status` 发生了变化，`is_advance` 不会自动更新

---

## 三、实现目标逻辑时需要注意的坑

### 3.1 硬编码的 "前 50 章免费"

**位置**：`backend/routes/novelCreation.js` 第 1194 行

**问题**：
```javascript
if (chapterNumber <= 50) {
  // 前50章节：免费章节
  isAdvance = 0;
  keyCost = 0;
  unlockPrice = 0;
}
```

**影响**：
- 即使 `unlockprice.default_free_chapters = 30`，前 30-50 章的 `key_cost` 和 `is_advance` 仍然按照免费章节处理
- 应该改为使用 `unlockprice.default_free_chapters`

**修复建议**：
```javascript
// 先查询 unlockprice 表，获取 default_free_chapters
// 然后使用该值判断
if (chapterNumber <= defaultFreeChapters) {
  isAdvance = 0;
  keyCost = 0;
  unlockPrice = 0;
}
```

---

### 3.2 旧的 unlockprice 结构

**已废弃的字段**（在迁移脚本中发现）：
- `fixed_style`
- `fixed_cost`
- `random_cost_min`
- `random_cost_max`

**迁移脚本**：`backend/migrations/add_pricing_system_fields.sql`

**状态**：
- ✅ **已迁移**：迁移脚本会删除这些字段
- ⚠️ **文档未更新**：`backend/CHAPTER_UPLOAD_BUSINESS_LOGIC.md` 中仍然描述了旧的逻辑（固定/随机模式）

**建议**：
- 更新 `CHAPTER_UPLOAD_BUSINESS_LOGIC.md` 文档，移除旧逻辑的描述

---

### 3.3 兼容老数据的需求

**当前情况**：
- 代码中已经使用了新的 `unlockprice` 结构（`karma_per_1000`, `min_karma`, `max_karma`, `default_free_chapters`）
- 如果数据库中还有旧的 `unlockprice` 记录（使用 `fixed_style`, `fixed_cost` 等字段），需要处理

**建议**：
- 检查数据库中是否还有使用旧结构的记录
- 如果有，需要迁移到新结构，或者添加兼容逻辑

---

### 3.4 更新章节时的逻辑不一致

**问题**：
1. **保存草稿时**：不会更新 `unlock_price`、`key_cost`、`is_advance`
2. **发布时**：只更新 `unlock_price`，不更新 `key_cost` 和 `is_advance`
3. **可能导致**：如果用户修改了章节号或字数，这些字段不会自动更新

**建议**：
- 在更新章节时，如果修改了 `chapter_number` 或 `word_count`，应该重新计算 `unlock_price`、`key_cost`、`is_advance`
- 或者在发布操作时，统一重新计算这些字段

---

### 3.5 pricing_style 的处理

**当前实现**：
- 代码中只支持 `pricing_style = 'per_word'`
- 创建 `unlockprice` 记录时，默认设置为 `'per_word'`

**目标逻辑**：
- 目前只考虑 `pricing_style = 'per_word'`
- 如果现有代码中支持了其他模式，请在分析报告里一并列出来

**分析结果**：
- ✅ **只支持 `'per_word'` 模式**
- ✅ **没有发现其他模式的实现**

---

## 四、总结

### 4.1 已实现的功能

1. ✅ **按字数计价公式**：完全符合目标逻辑
2. ✅ **is_advance 滑动窗口逻辑**：完全符合目标逻辑
3. ✅ **unlockprice 表的读写**：已正确实现
4. ✅ **自动创建 unlockprice 记录**：已实现

### 4.2 需要修复的问题

1. ❌ **硬编码 "前 50 章免费"**：
   - 位置：`backend/routes/novelCreation.js` 第 1194 行
   - 应该改为使用 `unlockprice.default_free_chapters`

2. ⚠️ **更新章节时逻辑不一致**：
   - 保存草稿时不会更新 `unlock_price`、`key_cost`、`is_advance`
   - 发布时只更新 `unlock_price`，不更新 `key_cost` 和 `is_advance`

3. ⚠️ **文档未更新**：
   - `backend/CHAPTER_UPLOAD_BUSINESS_LOGIC.md` 中仍然描述了旧的逻辑（固定/随机模式）

### 4.3 需要注意的兼容性问题

1. **旧数据迁移**：检查数据库中是否还有使用旧 `unlockprice` 结构的记录
2. **章节号修改**：如果用户修改了章节号，需要重新计算相关字段
3. **champion_status 变化**：如果 `champion_status` 从 `'approved'` 变为其他值，需要更新所有章节的 `is_advance`

---

**报告结束**

