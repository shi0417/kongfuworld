# 作品数据相关表 & 代码现状分析报告

**生成时间**：2025-01-XX  
**分析目标**：全面梳理项目中与作品数据评价相关的表结构、字段用途、业务流程，为设计作品数据评价系统提供基础数据

---

## 一、核心数据表结构分析

### 1.1 `reading_log` 表（阅读记录表）

#### 表结构

```sql
CREATE TABLE `reading_log` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NOT NULL,
  `chapter_id` int NOT NULL,
  `read_at` datetime DEFAULT CURRENT_TIMESTAMP,
  `is_unlocked` tinyint(1) DEFAULT 0 COMMENT '用户阅读时章节是否已解锁（是否永久拥有）',
  `unlock_time` datetime NULL COMMENT '该章节的解锁时间',
  `page_enter_time` datetime NULL COMMENT '进入页面的时间',
  `page_exit_time` datetime NULL COMMENT '离开页面的时间',
  `stay_duration` int NULL COMMENT '停留时间（秒）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 字段用途分析

**✅ 核心字段（有完整写入逻辑）**：
- `id`：主键，自增
- `user_id`：用户ID，关联 `user.id`
- `chapter_id`：章节ID，关联 `chapter.id`
- `read_at`：阅读时间，默认 `CURRENT_TIMESTAMP`

**⚠️ 扩展字段（部分实现）**：
- `is_unlocked`：是否已解锁，在 `POST /api/user/:userId/read-chapter` 中有写入逻辑
- `unlock_time`：解锁时间，在 `POST /api/user/:userId/read-chapter` 中有写入逻辑
- `page_enter_time`：进入页面时间，在 `POST /api/user/:userId/read-chapter` 中写入 `NOW()`
- `page_exit_time`：离开页面时间，通过 `POST /api/reading-timing/update-timing` 更新
- `stay_duration`：停留时长（秒），通过 `POST /api/reading-timing/update-timing` 计算并更新

#### 写入逻辑位置

**主要写入点**：
1. **`backend/server.js:2776`** - `POST /api/user/:userId/read-chapter`
   - 逻辑：用户访问章节阅读页面时记录
   - 写入字段：`user_id`, `chapter_id`, `read_at`, `is_unlocked`, `unlock_time`, `page_enter_time`
   - 更新逻辑：如果当天已有记录，更新 `read_at`；否则插入新记录

2. **`backend/routes/reading_timing.js:73`** - `POST /api/reading-timing/update-timing`
   - 逻辑：用户离开章节页面时更新时间追踪
   - 更新字段：`page_enter_time`, `page_exit_time`, `stay_duration`
   - 计算方式：`stay_duration = (page_exit_time - page_enter_time) / 1000`（秒）

#### 时间追踪字段实际逻辑

**当前实现状态**：
- ✅ `page_enter_time`：在进入章节页面时写入（`NOW()`）
- ⚠️ `page_exit_time`：需要前端调用 `POST /api/reading-timing/update-timing` 更新
- ⚠️ `stay_duration`：需要前端调用 `POST /api/reading-timing/update-timing` 计算并更新

**潜在问题**：
- 如果用户直接关闭浏览器或标签页，`page_exit_time` 和 `stay_duration` 可能不会被更新
- 建议使用 `beforeunload` 或 `sendBeacon` API 确保数据不丢失

#### 索引情况

根据 `backend/optimize_reading_log_table.sql`，建议的索引：
- `idx_user_chapter_time (user_id, chapter_id, read_at)`
- `idx_timing_fields (page_enter_time, page_exit_time, stay_duration)`

---

### 1.2 `chapter_unlocks` 表（章节解锁记录表）

#### 表结构

```sql
CREATE TABLE `chapter_unlocks` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NOT NULL COMMENT '读者用户ID',
  `chapter_id` int NOT NULL COMMENT '章节ID',
  `unlock_method` enum('free','key','karma','subscription','auto_unlock','time_unlock') NOT NULL COMMENT '解锁方式',
  `cost` int DEFAULT '0' COMMENT '实际花费的钥匙或业力数量',
  `unlocked_at` datetime DEFAULT NULL COMMENT '解锁时间',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  `first_clicked_at` datetime DEFAULT NULL COMMENT '首次点击时间',
  `unlock_at` datetime DEFAULT NULL COMMENT '预计解锁时间',
  `updated_at` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `status` enum('pending','unlocked','cancelled') DEFAULT NULL,
  `next_chapter_id` int DEFAULT NULL COMMENT '下一章节ID',
  `readed` tinyint(1) DEFAULT '0' COMMENT '是否已阅读',
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_user_chapter` (`user_id`,`chapter_id`),
  KEY `chapter_id` (`chapter_id`),
  FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE CASCADE,
  FOREIGN KEY (`chapter_id`) REFERENCES `chapter` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 字段用途分析

**核心字段**：
- `unlock_method`：解锁方式
  - `'free'`：免费解锁
  - `'key'`：钥匙解锁（Cultivation Keys）
  - `'karma'`：业力购买
  - `'subscription'`：Champion订阅解锁
  - `'auto_unlock'`：自动解锁
  - `'time_unlock'`：倒计时免费解锁

- `cost`：实际花费的钥匙或业力数量
  - 当 `unlock_method = 'key'` 时，表示花费的钥匙数
  - 当 `unlock_method = 'karma'` 时，表示花费的业力数
  - 当 `unlock_method = 'free'` 或 `'subscription'` 时，通常为 0

- `status`：解锁状态
  - `'pending'`：待解锁（倒计时解锁中）
  - `'unlocked'`：已解锁
  - `'cancelled'`：已取消

#### 业务使用方式

**解锁流程**（基于 `backend/routes/chapter_unlock.js`）：

1. **钥匙解锁**：`POST /api/chapter-unlock/unlock-with-key/:chapterId/:userId`
   - 检查用户钥匙余额
   - 扣除钥匙
   - 插入/更新 `chapter_unlocks` 记录：`unlock_method='key'`, `cost=钥匙数`, `status='unlocked'`

2. **业力解锁**：`POST /api/chapter-unlock/unlock-with-karma/:chapterId/:userId`
   - 检查用户业力余额
   - 扣除业力
   - 插入/更新 `chapter_unlocks` 记录：`unlock_method='karma'`, `cost=业力数`, `status='unlocked'`

3. **订阅解锁**：通过 `user_champion_subscription` 表判断，不直接写入 `chapter_unlocks`
   - 如果用户有有效的 Champion 订阅，章节自动解锁
   - 解锁方式在业务逻辑中判断为 `'subscription'`

4. **倒计时解锁**：`unlock_method='time_unlock'`, `status='pending'`
   - 创建倒计时记录
   - 倒计时结束后，`status` 更新为 `'unlocked'`

#### 与收入统计的关联

根据 `backend/编辑基础收入-4页面现状分析报告.md`：
- `chapter_unlocks.id` 可以作为 `reader_spending.source_id`（当 `source_type='chapter_unlock'` 时）
- 用于统计章节解锁收入

---

### 1.3 `user_champion_subscription` 表（用户Champion订阅表）

#### 表结构

```sql
CREATE TABLE `user_champion_subscription` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NOT NULL,
  `novel_id` int NOT NULL,
  `tier_level` int NOT NULL COMMENT 'Champion等级',
  `tier_name` varchar(100) NOT NULL COMMENT '等级名称',
  `monthly_price` decimal(10,2) NOT NULL COMMENT '月费',
  `start_date` datetime NOT NULL COMMENT '订阅开始时间',
  `end_date` datetime NOT NULL COMMENT '订阅结束时间',
  `is_active` tinyint(1) DEFAULT 1 COMMENT '是否激活',
  `payment_method` varchar(50) COMMENT '支付方式',
  `auto_renew` tinyint(1) DEFAULT 1 COMMENT '是否自动续费',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_user_novel` (`user_id`, `novel_id`),
  FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON DELETE CASCADE,
  FOREIGN KEY (`novel_id`) REFERENCES `novel`(`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 字段用途分析

**核心字段**：
- `tier_level`：订阅等级（1-13），对应不同的月费和预读章节数
- `monthly_price`：月费价格（原价，不含折扣）
- `start_date` / `end_date`：订阅时间范围
- `is_active`：是否激活（1=激活，0=已取消或过期）

#### 与 `user_champion_subscription_record` 的关系

**`user_champion_subscription`**：
- 存储用户当前的订阅状态（每个用户每本小说只有一条记录）
- 用于判断用户是否有权限解锁章节

**`user_champion_subscription_record`**：
- 存储每次支付的详细记录（每次续费都会新增一条记录）
- 用于统计收入和支付历史

**关系**：
- `user_champion_subscription` 是"当前状态表"
- `user_champion_subscription_record` 是"历史记录表"
- 两者通过 `user_id` + `novel_id` 关联

---

### 1.4 `user_champion_subscription_record` 表（Champion订阅支付记录表）

#### 表结构

```sql
CREATE TABLE `user_champion_subscription_record` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL COMMENT '用户ID',
  `novel_id` int(11) NOT NULL COMMENT '小说ID',
  `payment_record_id` int(11) NOT NULL COMMENT '关联的payment_record表ID',
  `tier_level` int(2) NOT NULL COMMENT '订阅等级',
  `tier_name` varchar(50) NOT NULL COMMENT '订阅等级名称',
  `monthly_price` decimal(10,2) NOT NULL COMMENT '月费价格',
  `payment_amount` decimal(10,2) NOT NULL COMMENT '实际支付金额',
  `payment_method` varchar(20) NOT NULL COMMENT '支付方式',
  `payment_status` varchar(20) NOT NULL DEFAULT 'pending' COMMENT '支付状态',
  `subscription_type` varchar(20) NOT NULL DEFAULT 'new' COMMENT '订阅类型',
  `subscription_duration_months` int(3) NOT NULL DEFAULT 1 COMMENT '订阅时长(月)',
  `start_date` datetime NOT NULL COMMENT '订阅开始时间',
  `end_date` datetime NOT NULL COMMENT '订阅结束时间',
  `is_active` tinyint(1) NOT NULL DEFAULT 1 COMMENT '是否激活',
  `auto_renew` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否自动续费',
  -- 其他支付相关字段（transaction_id, stripe_payment_intent_id等）
  `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_novel_id` (`novel_id`),
  KEY `idx_payment_status` (`payment_status`),
  KEY `idx_subscription_type` (`subscription_type`),
  KEY `idx_created_at` (`created_at`),
  KEY `idx_start_date` (`start_date`),
  KEY `idx_end_date` (`end_date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 关键字段说明

**收入相关字段**：
- `payment_amount`：实际支付金额（含折扣）
- `monthly_price`：原价（不含折扣）
- `discount_amount`：折扣金额（`monthly_price - payment_amount`）
- `payment_status`：支付状态（`'completed'` 表示已支付成功）

**订阅类型字段**：
- `subscription_type`：
  - `'new'`：新订阅
  - `'renew'`：续费
  - `'upgrade'`：升级（从低等级升级到高等级）
  - `'extend'`：延长（在现有订阅基础上延长）

**时间字段**：
- `start_date` / `end_date`：订阅时间范围
- `created_at`：支付记录创建时间（用于统计收入）

#### 业务用途

**收入统计**（基于 `backend/routes/admin.js:688`）：
- 统计总订阅收入：`SUM(payment_amount) WHERE payment_status='completed'`
- 统计今日收入：`SUM(payment_amount) WHERE payment_status='completed' AND DATE(created_at)=CURDATE()`
- 统计本月收入：`SUM(payment_amount) WHERE payment_status='completed' AND created_at>=本月第一天`

**订阅用户统计**：
- 活跃订阅用户数：`COUNT(DISTINCT user_id) WHERE is_active=1 AND end_date>NOW()`
- 订阅等级分布：`GROUP BY tier_level`

---

### 1.5 `review` 表（小说评价表）

#### 表结构

```sql
CREATE TABLE `review` (
  `id` int NOT NULL AUTO_INCREMENT,
  `parent_id` int DEFAULT NULL COMMENT '父评论ID，用于存储对该评论的子评论',
  `novel_id` int NOT NULL,
  `user_id` int NOT NULL,
  `content` text,
  `rating` int DEFAULT NULL COMMENT '评分（1-5星）',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  `likes` int DEFAULT '0' COMMENT '点赞数',
  `dislikes` int DEFAULT '0' COMMENT '点踩数',
  `comments` int DEFAULT '0' COMMENT '评论数',
  `views` int DEFAULT '0' COMMENT '浏览量',
  `is_recommended` tinyint(1) DEFAULT '0' COMMENT '是否推荐',
  PRIMARY KEY (`id`),
  KEY `idx_parent_id` (`parent_id`),
  KEY `novel_id` (`novel_id`),
  KEY `user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 字段用途分析

**核心字段**：
- `rating`：评分（1-5星），用于计算小说平均评分
- `likes` / `dislikes`：点赞/点踩数（冗余统计字段）
- `parent_id`：父评论ID，支持回复功能

**点赞/点踩逻辑**（基于 `docs/review-comment-like-system-baseline.md`）：
- 使用 `review_like` 和 `review_dislike` 两个表存储明细
- 点赞/点踩时更新 `review.likes` / `review.dislikes` 统计字段

---

### 1.6 `comment` 表（通用评论表）

#### 表结构

```sql
CREATE TABLE `comment` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NOT NULL,
  `target_type` enum('novel','chapter','paragraph','review') NOT NULL,
  `target_id` int NOT NULL COMMENT '章节ID，comment表只存储章节评论',
  `novel_id` int DEFAULT NULL COMMENT '小说ID，从chapter表关联获取',
  `parent_comment_id` int DEFAULT NULL,
  `content` text NOT NULL,
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  `likes` int DEFAULT '0',
  `dislikes` int DEFAULT '0',
  PRIMARY KEY (`id`),
  KEY `idx_novel_id` (`novel_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 字段用途分析

**核心字段**：
- `target_type`：评论类型
  - `'novel'`：对小说的评论
  - `'chapter'`：对章节的评论（主要用途）
  - `'paragraph'`：对段落的评论
  - `'review'`：对评价的回复

- `target_id`：目标ID（根据 `target_type` 确定）
- `novel_id`：小说ID（冗余字段，用于快速查询）

**点赞/点踩逻辑**：
- 使用 `comment_like` 和 `comment_dislike` 两个表存储明细
- 点赞/点踩时更新 `comment.likes` / `comment.dislikes` 统计字段

---

### 1.7 `paragraph_comment` 表（段落评论表）

#### 表结构（推测）

```sql
CREATE TABLE `paragraph_comment` (
  `id` int NOT NULL AUTO_INCREMENT,
  `chapter_id` int NOT NULL,
  `paragraph_index` int NOT NULL,
  `novel_id` int DEFAULT NULL,
  `user_id` int NOT NULL,
  `content` text NOT NULL,
  `parent_id` int DEFAULT NULL,
  `like_count` int DEFAULT '0',
  `dislike_count` int DEFAULT '0',
  `is_deleted` tinyint(1) DEFAULT '0',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### 字段用途分析

**核心字段**：
- `paragraph_index`：段落索引（章节中的第几段）
- `like_count` / `dislike_count`：点赞/点踩数（冗余统计字段）
- `is_deleted`：软删除标记

**点赞/点踩逻辑**：
- 使用 `paragraph_comment_like` 表存储明细（单表 + `is_like` 字段）
- `is_like=1` 表示点赞，`is_like=0` 表示点踩
- 通过聚合 `paragraph_comment_like` 表回写 `like_count` / `dislike_count`

---

### 1.8 `novel` 表（小说主表）

#### 表结构（关键字段）

```sql
CREATE TABLE `novel` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int DEFAULT NULL COMMENT '作者用户ID',
  `title` varchar(255) NOT NULL,
  `status` varchar(50) DEFAULT NULL COMMENT '状态（Ongoing/Completed）',
  `cover` varchar(255) DEFAULT NULL,
  `rating` int DEFAULT '0' COMMENT '评分',
  `reviews` int DEFAULT '0' COMMENT '评论数',
  `author` varchar(100) DEFAULT NULL,
  `chapters` int DEFAULT '0' COMMENT '章节数',
  `review_status` enum('created','submitted','reviewing','approved','published','unlisted','archived','locked') DEFAULT 'created',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_review_status` (`review_status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 字段用途分析

**统计字段**：
- `rating`：评分（当前使用情况不明确，可能需要从 `review` 表聚合计算）
- `reviews`：评论数（冗余统计字段）
- `chapters`：章节数（冗余统计字段）

---

### 1.9 `chapter` 表（章节表）

#### 表结构（关键字段）

```sql
CREATE TABLE `chapter` (
  `id` int NOT NULL AUTO_INCREMENT,
  `novel_id` int NOT NULL,
  `volume_id` int NOT NULL,
  `chapter_number` int NOT NULL,
  `title` varchar(255) NOT NULL,
  `content` text,
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  `review_status` enum('submitted','reviewing','approved','rejected','draft') DEFAULT 'submitted',
  `is_released` tinyint(1) DEFAULT '1' COMMENT '是否已发布',
  `release_date` datetime DEFAULT NULL COMMENT '发布日期',
  `unlock_price` int DEFAULT '0' COMMENT '解锁所需钥匙数量',
  `key_cost` int DEFAULT 1 COMMENT '钥匙解锁成本',
  `karma_cost` int DEFAULT 32 COMMENT '业力购买成本',
  PRIMARY KEY (`id`),
  KEY `novel_id` (`novel_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 字段用途分析

**解锁相关字段**：
- `unlock_price`：解锁所需钥匙数量（0表示免费）
- `key_cost`：钥匙解锁成本
- `karma_cost`：业力购买成本

**发布相关字段**：
- `is_released`：是否已发布
- `release_date`：发布日期
- `review_status`：审核状态（只有 `'approved'` 的章节才能被阅读）

---

## 二、现有统计表分析

### 2.1 `novel_statistics` 表（小说每日统计表）

#### 表结构

```sql
CREATE TABLE `novel_statistics` (
  `id` int NOT NULL AUTO_INCREMENT,
  `novel_id` int NOT NULL,
  `date` date NOT NULL COMMENT '统计日期',
  `views` int DEFAULT 0 COMMENT '当日浏览量',
  `reads` int DEFAULT 0 COMMENT '当日阅读量',
  `favorites` int DEFAULT 0 COMMENT '当日收藏量',
  `comments` int DEFAULT 0 COMMENT '当日评论量',
  `shares` int DEFAULT 0 COMMENT '当日分享量',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_novel_date` (`novel_id`, `date`),
  KEY `date` (`date`),
  KEY `views` (`views`),
  KEY `reads` (`reads`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 使用场景

**主要用途**（基于 `backend/NOVEL_STATISTICS_TABLE_DOC.md`）：
1. **首页热门小说排序**：`GET /api/homepage/popular-this-week`
   - 根据最近7天的 `views` 和 `reads` 排序

2. **数据更新时机**：
   - 浏览量：`POST /api/novel/:id/view` 时更新 `views`
   - 阅读量：通过 `reading_log` 统计（具体更新逻辑待确认）

#### 当前指标口径

- `views`：小说详情页访问次数
- `reads`：章节阅读次数（基于 `reading_log`）
- `favorites`：收藏次数（基于 `favorite` 表）
- `comments`：评论次数（基于 `comment` 表）
- `shares`：分享次数（具体实现待确认）

---

## 三、现有排行榜/榜单接口

### 3.1 首页榜单接口

**位置**：`backend/server.js:1841-1898`

1. **本周热门**：`GET /api/homepage/popular-this-week`
   - 排序依据：最近7天的 `views` + `reads`
   - SQL：`ORDER BY weekly_views DESC, weekly_reads DESC`

2. **最新发布**：`GET /api/homepage/new-releases`
   - 排序依据：最新章节发布时间
   - SQL：`ORDER BY latest_chapter_date DESC`

3. **高分系列**：`GET /api/homepage/top-series`
   - 排序依据：`rating` + `reviews`
   - SQL：`ORDER BY rating DESC, reviews DESC`

### 3.2 综合首页接口

**位置**：`backend/server.js:1991-2094`

**接口**：`GET /api/homepage/all`
- 返回所有榜单数据（banners、popularNovels、newReleases、topSeries）

---

## 四、业务流程总结

### 4.1 章节阅读流程

1. **用户访问章节**：`POST /api/user/:userId/read-chapter`
   - 写入 `reading_log`：`user_id`, `chapter_id`, `read_at`, `is_unlocked`, `unlock_time`, `page_enter_time`

2. **用户离开章节**：`POST /api/reading-timing/update-timing`
   - 更新 `reading_log`：`page_exit_time`, `stay_duration`

### 4.2 章节解锁流程

1. **钥匙解锁**：`POST /api/chapter-unlock/unlock-with-key/:chapterId/:userId`
   - 扣除用户钥匙
   - 插入/更新 `chapter_unlocks`：`unlock_method='key'`, `cost=钥匙数`, `status='unlocked'`

2. **业力解锁**：`POST /api/chapter-unlock/unlock-with-karma/:chapterId/:userId`
   - 扣除用户业力
   - 插入/更新 `chapter_unlocks`：`unlock_method='karma'`, `cost=业力数`, `status='unlocked'`

3. **订阅解锁**：通过 `user_champion_subscription` 判断
   - 如果 `is_active=1` 且 `end_date>NOW()`，章节自动解锁

### 4.3 Champion订阅流程

1. **购买订阅**：通过 Stripe/PayPal 支付
   - 写入 `user_champion_subscription_record`：支付记录
   - 更新/插入 `user_champion_subscription`：当前订阅状态

2. **自动续费**：Stripe 自动扣款
   - 每次扣款写入新的 `user_champion_subscription_record` 记录
   - 更新 `user_champion_subscription.end_date`

### 4.4 评价/评论流程

1. **小说评价**：用户对小说评分和评论
   - 写入 `review` 表
   - 更新 `novel.rating` 和 `novel.reviews`（需要确认是否有自动更新逻辑）

2. **章节评论**：用户对章节评论
   - 写入 `comment` 表（`target_type='chapter'`）

3. **段落评论**：用户对段落评论
   - 写入 `paragraph_comment` 表

4. **点赞/点踩**：
   - 写入 `review_like` / `review_dislike` 或 `comment_like` / `comment_dislike` 或 `paragraph_comment_like`
   - 更新主表的 `likes` / `dislikes` 字段

---

## 五、关键发现与问题

### 5.1 数据完整性问题

1. **`reading_log.stay_duration` 可能不完整**
   - 如果用户直接关闭浏览器，`page_exit_time` 和 `stay_duration` 可能不会被更新
   - 建议使用 `beforeunload` 或 `sendBeacon` API

2. **`novel.rating` 更新逻辑不明确**
   - 需要确认是否有定时任务或触发器自动从 `review` 表聚合计算

3. **`novel_statistics.reads` 更新逻辑不明确**
   - 需要确认是否有定时任务从 `reading_log` 统计并更新

### 5.2 统计口径问题

1. **阅读量统计**
   - 当前 `novel_statistics.reads` 的口径不明确
   - 建议明确：是按 `reading_log` 记录数统计，还是按唯一用户数统计

2. **评分计算**
   - 当前 `novel.rating` 的计算方式不明确
   - 建议明确：是简单平均，还是加权平均（考虑点赞数、评论数等）

### 5.3 缺失的统计维度

1. **阅读深度统计**
   - 当前没有统计"首章阅读数"、"深度阅读数"（阅读超过N章的用户数）

2. **留存统计**
   - 当前没有统计"连续阅读天数"、"回访情况"

3. **付费转化统计**
   - 当前没有统计"解锁转化率"（阅读付费章节的用户数 / 阅读首章的用户数）

4. **社区活跃度统计**
   - 当前没有统计"评论回复率"、"讨论深度"等

---

## 六、总结

### 6.1 现有数据基础

**✅ 已有数据**：
- 阅读记录：`reading_log`（含时间追踪字段）
- 解锁记录：`chapter_unlocks`（含解锁方式和成本）
- 订阅记录：`user_champion_subscription` + `user_champion_subscription_record`
- 评价/评论：`review` + `comment` + `paragraph_comment`（含点赞/点踩）
- 每日统计：`novel_statistics`（含浏览量、阅读量等）

**⚠️ 需要完善**：
- `reading_log.stay_duration` 的完整性
- `novel.rating` 的自动更新逻辑
- `novel_statistics.reads` 的更新逻辑

### 6.2 现有排行榜

**已有榜单**：
- 本周热门（基于 `novel_statistics` 的7天数据）
- 最新发布（基于章节发布时间）
- 高分系列（基于 `novel.rating` + `novel.reviews`）

**缺失榜单**：
- 24小时热榜
- 新书榜（限定上架时间）
- 畅销榜（按收入）
- 好评榜（按口碑）

### 6.3 下一步工作建议

1. **完善数据收集**：确保 `reading_log.stay_duration` 的完整性
2. **建立统计任务**：定时从明细表聚合统计到 `novel_statistics`
3. **设计评价系统**：基于现有数据设计多维度评价指标
4. **扩展排行榜**：增加更多榜单类型

---

**报告结束**

